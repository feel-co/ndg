<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `MAIN_JS` constant in crate `ndg`."><title>MAIN_JS in ndg::utils::assets - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="ndg" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0-nightly (27b076af7 2025-11-21)" data-channel="nightly" data-search-js="search-680b2199.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">MAIN_JS</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../ndg/index.html">ndg</a><span class="version">2.4.1</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In ndg::<wbr>utils::<wbr>assets</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">ndg</a>::<wbr><a href="../index.html">utils</a>::<wbr><a href="index.html">assets</a></div><h1>Constant <span class="constant">MAIN_JS</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/ndg/utils/assets.rs.html#12">Source</a> </span></div><pre class="rust item-decl"><code>const MAIN_JS: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;// Polyfill for requestIdleCallback for Safari and unsupported browsers\nif (typeof window.requestIdleCallback === \&quot;undefined\&quot;) {\n  window.requestIdleCallback = function (cb) {\n    var start = Date.now();\n    var idlePeriod = 50;\n    return setTimeout(function () {\n      cb({\n        didTimeout: false,\n        timeRemaining: function () {\n          return Math.max(0, idlePeriod - (Date.now() - start));\n        },\n      });\n    }, 1);\n  };\n  window.cancelIdleCallback = function (id) {\n    clearTimeout(id);\n  };\n}\n\n// Create mobile elements if they don\&#39;t exist\nfunction createMobileElements() {\n  // Create mobile sidebar FAB\n  const mobileFab = document.createElement(\&quot;button\&quot;);\n  mobileFab.className = \&quot;mobile-sidebar-fab\&quot;;\n  mobileFab.setAttribute(\&quot;aria-label\&quot;, \&quot;Toggle sidebar menu\&quot;);\n  mobileFab.innerHTML = `\n    &lt;svg xmlns=\&quot;http://www.w3.org/2000/svg\&quot; viewBox=\&quot;0 0 24 24\&quot; width=\&quot;24\&quot; height=\&quot;24\&quot; fill=\&quot;none\&quot; stroke=\&quot;currentColor\&quot; stroke-width=\&quot;2\&quot; stroke-linecap=\&quot;round\&quot; stroke-linejoin=\&quot;round\&quot;&gt;\n      &lt;line x1=\&quot;3\&quot; y1=\&quot;12\&quot; x2=\&quot;21\&quot; y2=\&quot;12\&quot;&gt;&lt;/line&gt;\n      &lt;line x1=\&quot;3\&quot; y1=\&quot;6\&quot; x2=\&quot;21\&quot; y2=\&quot;6\&quot;&gt;&lt;/line&gt;\n      &lt;line x1=\&quot;3\&quot; y1=\&quot;18\&quot; x2=\&quot;21\&quot; y2=\&quot;18\&quot;&gt;&lt;/line&gt;\n    &lt;/svg&gt;\n  `;\n\n  // Only show FAB on mobile (max-width: 800px)\n  function updateFabVisibility() {\n    if (window.innerWidth &gt; 800) {\n      if (mobileFab.parentNode) mobileFab.parentNode.removeChild(mobileFab);\n    } else {\n      if (!document.body.contains(mobileFab)) {\n        document.body.appendChild(mobileFab);\n      }\n      mobileFab.style.display = \&quot;flex\&quot;;\n    }\n  }\n  updateFabVisibility();\n  window.addEventListener(\&quot;resize\&quot;, updateFabVisibility);\n\n  // Create mobile sidebar container\n  const mobileContainer = document.createElement(\&quot;div\&quot;);\n  mobileContainer.className = \&quot;mobile-sidebar-container\&quot;;\n  mobileContainer.innerHTML = `\n    &lt;div class=\&quot;mobile-sidebar-handle\&quot;&gt;\n      &lt;div class=\&quot;mobile-sidebar-dragger\&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\&quot;mobile-sidebar-content\&quot;&gt;\n      &lt;!-- Sidebar content will be cloned here --&gt;\n    &lt;/div&gt;\n  `;\n\n  // Create mobile search popup\n  const mobileSearchPopup = document.createElement(\&quot;div\&quot;);\n  mobileSearchPopup.id = \&quot;mobile-search-popup\&quot;;\n  mobileSearchPopup.className = \&quot;mobile-search-popup\&quot;;\n  mobileSearchPopup.innerHTML = `\n    &lt;div class=\&quot;mobile-search-container\&quot;&gt;\n      &lt;div class=\&quot;mobile-search-header\&quot;&gt;\n        &lt;input type=\&quot;text\&quot; id=\&quot;mobile-search-input\&quot; placeholder=\&quot;Search...\&quot; /&gt;\n        &lt;button id=\&quot;close-mobile-search\&quot; class=\&quot;close-mobile-search\&quot; aria-label=\&quot;Close search\&quot;&gt;&amp;times;&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div id=\&quot;mobile-search-results\&quot; class=\&quot;mobile-search-results\&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `;\n\n  // Insert at end of body so it is not affected by .container flex or stacking context\n  document.body.appendChild(mobileContainer);\n  document.body.appendChild(mobileSearchPopup);\n\n  // Immediately populate mobile sidebar content if desktop sidebar exists\n  const desktopSidebar = document.querySelector(\&quot;.sidebar\&quot;);\n  const mobileSidebarContent = mobileContainer.querySelector(\n    \&quot;.mobile-sidebar-content\&quot;,\n  );\n  if (desktopSidebar &amp;&amp; mobileSidebarContent) {\n    mobileSidebarContent.innerHTML = desktopSidebar.innerHTML;\n  }\n}\n\ndocument.addEventListener(\&quot;DOMContentLoaded\&quot;, function () {\n  // Apply sidebar state immediately before DOM rendering\n  if (localStorage.getItem(\&quot;sidebar-collapsed\&quot;) === \&quot;true\&quot;) {\n    document.documentElement.classList.add(\&quot;sidebar-collapsed\&quot;);\n    document.body.classList.add(\&quot;sidebar-collapsed\&quot;);\n  }\n\n  if (!document.querySelector(\&quot;.mobile-sidebar-fab\&quot;)) {\n    createMobileElements();\n  }\n\n  // Desktop Sidebar Toggle\n  const sidebarToggle = document.querySelector(\&quot;.sidebar-toggle\&quot;);\n\n  // On page load, sync the state from `documentElement` to `body`\n  if (document.documentElement.classList.contains(\&quot;sidebar-collapsed\&quot;)) {\n    document.body.classList.add(\&quot;sidebar-collapsed\&quot;);\n  }\n\n  if (sidebarToggle) {\n    sidebarToggle.addEventListener(\&quot;click\&quot;, function () {\n      // Toggle on both elements for consistency\n      document.documentElement.classList.toggle(\&quot;sidebar-collapsed\&quot;);\n      document.body.classList.toggle(\&quot;sidebar-collapsed\&quot;);\n\n      // Use documentElement to check state and save to localStorage\n      const isCollapsed =\n        document.documentElement.classList.contains(\&quot;sidebar-collapsed\&quot;);\n      localStorage.setItem(\&quot;sidebar-collapsed\&quot;, isCollapsed);\n    });\n  }\n\n  // Make headings clickable for anchor links\n  const content = document.querySelector(\&quot;.content\&quot;);\n  if (content) {\n    const headings = content.querySelectorAll(\&quot;h1, h2, h3, h4, h5, h6\&quot;);\n\n    headings.forEach(function (heading) {\n      // Generate a valid, unique ID for each heading\n      if (!heading.id) {\n        let baseId = heading.textContent\n          .toLowerCase()\n          .replace(/[^a-z0-9\\s-_]/g, \&quot;\&quot;) // remove invalid chars\n          .replace(/^[^a-z]+/, \&quot;\&quot;) // remove leading non-letters\n          .replace(/[\\s-_]+/g, \&quot;-\&quot;)\n          .replace(/^-+|-+$/g, \&quot;\&quot;) // trim leading/trailing dashes\n          .trim();\n        if (!baseId) {\n          baseId = \&quot;section\&quot;;\n        }\n        let id = baseId;\n        let counter = 1;\n        while (document.getElementById(id)) {\n          id = `${baseId}-${counter++}`;\n        }\n        heading.id = id;\n      }\n\n      // Make the entire heading clickable\n      heading.addEventListener(\&quot;click\&quot;, function (e) {\n        const id = this.id;\n        history.pushState(null, null, \&quot;#\&quot; + id);\n\n        // Scroll with offset\n        const offset = this.getBoundingClientRect().top + window.scrollY - 80;\n        window.scrollTo({\n          top: offset,\n          behavior: \&quot;smooth\&quot;,\n        });\n      });\n    });\n  }\n\n  // Process footnotes\n  if (content) {\n    const footnoteContainer = document.querySelector(\&quot;.footnotes-container\&quot;);\n\n    // Find all footnote references and create a footnotes section\n    const footnoteRefs = content.querySelectorAll(\&#39;a[href^=\&quot;#fn\&quot;]\&#39;);\n    if (footnoteRefs.length &gt; 0) {\n      const footnotesDiv = document.createElement(\&quot;div\&quot;);\n      footnotesDiv.className = \&quot;footnotes\&quot;;\n\n      const footnotesHeading = document.createElement(\&quot;h2\&quot;);\n      footnotesHeading.textContent = \&quot;Footnotes\&quot;;\n      footnotesDiv.appendChild(footnotesHeading);\n\n      const footnotesList = document.createElement(\&quot;ol\&quot;);\n      footnoteContainer.appendChild(footnotesDiv);\n      footnotesDiv.appendChild(footnotesList);\n\n      // Add footnotes\n      document.querySelectorAll(\&quot;.footnote\&quot;).forEach((footnote) =&gt; {\n        const id = footnote.id;\n        const content = footnote.innerHTML;\n\n        const li = document.createElement(\&quot;li\&quot;);\n        li.id = id;\n        li.innerHTML = content;\n\n        // Add backlink\n        const backlink = document.createElement(\&quot;a\&quot;);\n        backlink.href = \&quot;#fnref:\&quot; + id.replace(\&quot;fn:\&quot;, \&quot;\&quot;);\n        backlink.className = \&quot;footnote-backlink\&quot;;\n        backlink.textContent = \&quot;\u{21a9}\&quot;;\n        li.appendChild(backlink);\n\n        footnotesList.appendChild(li);\n      });\n    }\n  }\n\n  // Copy link functionality\n  document.querySelectorAll(\&quot;.copy-link\&quot;).forEach(function (copyLink) {\n    copyLink.addEventListener(\&quot;click\&quot;, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Get option ID from parent element\n      const option = copyLink.closest(\&quot;.option\&quot;);\n      const optionId = option.id;\n\n      // Create URL with hash\n      const url = new URL(window.location.href);\n      url.hash = optionId;\n\n      // Copy to clipboard\n      navigator.clipboard\n        .writeText(url.toString())\n        .then(function () {\n          // Show feedback\n          const feedback = copyLink.nextElementSibling;\n          feedback.style.display = \&quot;inline\&quot;;\n\n          // Hide after 2 seconds\n          setTimeout(function () {\n            feedback.style.display = \&quot;none\&quot;;\n          }, 2000);\n        })\n        .catch(function (err) {\n          console.error(\&quot;Could not copy link: \&quot;, err);\n        });\n    });\n  });\n\n  // Handle initial hash navigation\n  function scrollToElement(element) {\n    if (element) {\n      const offset = element.getBoundingClientRect().top + window.scrollY - 80;\n      window.scrollTo({\n        top: offset,\n        behavior: \&quot;smooth\&quot;,\n      });\n    }\n  }\n\n  if (window.location.hash) {\n    const targetElement = document.querySelector(window.location.hash);\n    if (targetElement) {\n      setTimeout(() =&gt; scrollToElement(targetElement), 0);\n      // Add highlight class for options page\n      if (targetElement.classList.contains(\&quot;option\&quot;)) {\n        targetElement.classList.add(\&quot;highlight\&quot;);\n      }\n    }\n  }\n\n  // Mobile Sidebar Functionality\n  const mobileSidebarContainer = document.querySelector(\n    \&quot;.mobile-sidebar-container\&quot;,\n  );\n  const mobileSidebarFab = document.querySelector(\&quot;.mobile-sidebar-fab\&quot;);\n  const mobileSidebarContent = document.querySelector(\n    \&quot;.mobile-sidebar-content\&quot;,\n  );\n  const mobileSidebarHandle = document.querySelector(\&quot;.mobile-sidebar-handle\&quot;);\n  const desktopSidebar = document.querySelector(\&quot;.sidebar\&quot;);\n\n  // Always set up FAB if it exists\n  if (mobileSidebarFab &amp;&amp; mobileSidebarContainer) {\n    // Populate content if desktop sidebar exists\n    if (desktopSidebar &amp;&amp; mobileSidebarContent) {\n      mobileSidebarContent.innerHTML = desktopSidebar.innerHTML;\n    }\n\n    const openMobileSidebar = () =&gt; {\n      mobileSidebarContainer.classList.add(\&quot;active\&quot;);\n      mobileSidebarFab.setAttribute(\&quot;aria-expanded\&quot;, \&quot;true\&quot;);\n      mobileSidebarContainer.setAttribute(\&quot;aria-hidden\&quot;, \&quot;false\&quot;);\n      mobileSidebarFab.classList.add(\&quot;fab-hidden\&quot;); // hide FAB when drawer is open\n    };\n\n    const closeMobileSidebar = () =&gt; {\n      mobileSidebarContainer.classList.remove(\&quot;active\&quot;);\n      mobileSidebarFab.setAttribute(\&quot;aria-expanded\&quot;, \&quot;false\&quot;);\n      mobileSidebarContainer.setAttribute(\&quot;aria-hidden\&quot;, \&quot;true\&quot;);\n      mobileSidebarFab.classList.remove(\&quot;fab-hidden\&quot;); // Show FAB when drawer is closed\n    };\n\n    mobileSidebarFab.addEventListener(\&quot;click\&quot;, (e) =&gt; {\n      e.stopPropagation();\n      if (mobileSidebarContainer.classList.contains(\&quot;active\&quot;)) {\n        closeMobileSidebar();\n      } else {\n        openMobileSidebar();\n      }\n    });\n\n    // Only set up drag functionality if handle exists\n    if (mobileSidebarHandle) {\n      // Drag functionality\n      let isDragging = false;\n      let startY = 0;\n      let startHeight = 0;\n\n      // Cleanup function for drag interruption\n      function cleanupDrag() {\n        if (isDragging) {\n          isDragging = false;\n          mobileSidebarHandle.style.cursor = \&quot;grab\&quot;;\n          document.body.style.userSelect = \&quot;\&quot;;\n        }\n      }\n\n      mobileSidebarHandle.addEventListener(\&quot;mousedown\&quot;, (e) =&gt; {\n        isDragging = true;\n        startY = e.pageY;\n        startHeight = mobileSidebarContainer.offsetHeight;\n        mobileSidebarHandle.style.cursor = \&quot;grabbing\&quot;;\n        document.body.style.userSelect = \&quot;none\&quot;; // prevent text selection\n      });\n\n      mobileSidebarHandle.addEventListener(\&quot;touchstart\&quot;, (e) =&gt; {\n        isDragging = true;\n        startY = e.touches[0].pageY;\n        startHeight = mobileSidebarContainer.offsetHeight;\n      });\n\n      document.addEventListener(\&quot;mousemove\&quot;, (e) =&gt; {\n        if (!isDragging) return;\n        const deltaY = startY - e.pageY;\n        const newHeight = startHeight + deltaY;\n        const vh = window.innerHeight;\n        const minHeight = vh * 0.15;\n        const maxHeight = vh * 0.9;\n\n        if (newHeight &gt;= minHeight &amp;&amp; newHeight &lt;= maxHeight) {\n          mobileSidebarContainer.style.height = `${newHeight}px`;\n        }\n      });\n\n      document.addEventListener(\&quot;touchmove\&quot;, (e) =&gt; {\n        if (!isDragging) return;\n        const deltaY = startY - e.touches[0].pageY;\n        const newHeight = startHeight + deltaY;\n        const vh = window.innerHeight;\n        const minHeight = vh * 0.15;\n        const maxHeight = vh * 0.9;\n\n        if (newHeight &gt;= minHeight &amp;&amp; newHeight &lt;= maxHeight) {\n          mobileSidebarContainer.style.height = `${newHeight}px`;\n        }\n      });\n\n      document.addEventListener(\&quot;mouseup\&quot;, cleanupDrag);\n      document.addEventListener(\&quot;touchend\&quot;, cleanupDrag);\n      window.addEventListener(\&quot;blur\&quot;, cleanupDrag);\n      document.addEventListener(\&quot;visibilitychange\&quot;, function () {\n        if (document.hidden) cleanupDrag();\n      });\n    }\n\n    // Close on outside click\n    document.addEventListener(\&quot;click\&quot;, (event) =&gt; {\n      if (\n        mobileSidebarContainer.classList.contains(\&quot;active\&quot;) &amp;&amp;\n        !mobileSidebarContainer.contains(event.target) &amp;&amp;\n        !mobileSidebarFab.contains(event.target)\n      ) {\n        closeMobileSidebar();\n      }\n    });\n\n    // Close on escape key\n    document.addEventListener(\&quot;keydown\&quot;, (event) =&gt; {\n      if (\n        event.key === \&quot;Escape\&quot; &amp;&amp;\n        mobileSidebarContainer.classList.contains(\&quot;active\&quot;)\n      ) {\n        closeMobileSidebar();\n      }\n    });\n  }\n\n  \n\n  // Options filter functionality\n  const optionsFilter = document.getElementById(\&quot;options-filter\&quot;);\n  if (optionsFilter) {\n    const optionsContainer = document.querySelector(\&quot;.options-container\&quot;);\n    if (!optionsContainer) return;\n\n    // Only inject the style if it doesn\&#39;t already exist\n    if (!document.head.querySelector(\&quot;style[data-options-hidden]\&quot;)) {\n      const styleEl = document.createElement(\&quot;style\&quot;);\n      styleEl.setAttribute(\&quot;data-options-hidden\&quot;, \&quot;\&quot;);\n      styleEl.textContent = \&quot;.option-hidden{display:none!important}\&quot;;\n      document.head.appendChild(styleEl);\n    }\n\n    // Create filter results counter\n    const filterResults = document.createElement(\&quot;div\&quot;);\n    filterResults.className = \&quot;filter-results\&quot;;\n    optionsFilter.parentNode.insertBefore(\n      filterResults,\n      optionsFilter.nextSibling,\n    );\n\n    // Detect if we\&#39;re on a mobile device\n    const isMobile =\n      window.innerWidth &lt; 768 || /Mobi|Android/i.test(navigator.userAgent);\n\n    // Cache all option elements and their searchable content\n    const options = Array.from(document.querySelectorAll(\&quot;.option\&quot;));\n    const totalCount = options.length;\n\n    // Store the original order of option elements\n    const originalOptionOrder = options.slice();\n\n    // Pre-process and optimize searchable content\n    const optionsData = options.map((option) =&gt; {\n      const nameElem = option.querySelector(\&quot;.option-name\&quot;);\n      const descriptionElem = option.querySelector(\&quot;.option-description\&quot;);\n      const id = option.id ? option.id.toLowerCase() : \&quot;\&quot;;\n      const name = nameElem ? nameElem.textContent.toLowerCase() : \&quot;\&quot;;\n      const description = descriptionElem\n        ? descriptionElem.textContent.toLowerCase()\n        : \&quot;\&quot;;\n\n      // Extract keywords for faster searching\n      const keywords = (id + \&quot; \&quot; + name + \&quot; \&quot; + description)\n        .toLowerCase()\n        .split(/\\s+/)\n        .filter((word) =&gt; word.length &gt; 1);\n\n      return {\n        element: option,\n        id,\n        name,\n        description,\n        keywords,\n        searchText: (id + \&quot; \&quot; + name + \&quot; \&quot; + description).toLowerCase(),\n      };\n    });\n\n    // Chunk size and rendering variables\n    const CHUNK_SIZE = isMobile ? 15 : 40;\n    let pendingRender = null;\n    let currentChunk = 0;\n    let itemsToProcess = [];\n\n    function debounce(func, wait) {\n      let timeout;\n      return function () {\n        const context = this;\n        const args = arguments;\n        clearTimeout(timeout);\n        timeout = setTimeout(() =&gt; func.apply(context, args), wait);\n      };\n    }\n\n    // Process options in chunks to prevent UI freezing\n    function processNextChunk() {\n      const startIdx = currentChunk * CHUNK_SIZE;\n      const endIdx = Math.min(startIdx + CHUNK_SIZE, itemsToProcess.length);\n\n      if (startIdx &lt; itemsToProcess.length) {\n        // Process current chunk\n        for (let i = startIdx; i &lt; endIdx; i++) {\n          const item = itemsToProcess[i];\n          if (item.visible) {\n            item.element.classList.remove(\&quot;option-hidden\&quot;);\n          } else {\n            item.element.classList.add(\&quot;option-hidden\&quot;);\n          }\n        }\n\n        currentChunk++;\n        pendingRender = requestAnimationFrame(processNextChunk);\n      } else {\n        // Finished processing all chunks\n        pendingRender = null;\n        currentChunk = 0;\n        itemsToProcess = [];\n\n        // Update counter at the very end for best performance\n        if (filterResults.visibleCount !== undefined) {\n          if (filterResults.visibleCount &lt; totalCount) {\n            filterResults.textContent = `Showing ${filterResults.visibleCount} of ${totalCount} options`;\n            filterResults.style.display = \&quot;block\&quot;;\n          } else {\n            filterResults.style.display = \&quot;none\&quot;;\n          }\n        }\n      }\n    }\n\n    function filterOptions() {\n      const searchTerm = optionsFilter.value.toLowerCase().trim();\n\n      if (pendingRender) {\n        cancelAnimationFrame(pendingRender);\n        pendingRender = null;\n      }\n      currentChunk = 0;\n      itemsToProcess = [];\n\n      if (searchTerm === \&quot;\&quot;) {\n        // Restore original DOM order when filter is cleared\n        const fragment = document.createDocumentFragment();\n        originalOptionOrder.forEach((option) =&gt; {\n          option.classList.remove(\&quot;option-hidden\&quot;);\n          fragment.appendChild(option);\n        });\n        optionsContainer.appendChild(fragment);\n        filterResults.style.display = \&quot;none\&quot;;\n        return;\n      }\n\n      const searchTerms = searchTerm\n        .split(/\\s+/)\n        .filter((term) =&gt; term.length &gt; 0);\n      let visibleCount = 0;\n\n      const titleMatches = [];\n      const descMatches = [];\n      optionsData.forEach((data) =&gt; {\n        let isTitleMatch = false;\n        let isDescMatch = false;\n        if (searchTerms.length === 1) {\n          const term = searchTerms[0];\n          isTitleMatch = data.name.includes(term);\n          isDescMatch = !isTitleMatch &amp;&amp; data.description.includes(term);\n        } else {\n          isTitleMatch = searchTerms.every((term) =&gt; data.name.includes(term));\n          isDescMatch =\n            !isTitleMatch &amp;&amp;\n            searchTerms.every((term) =&gt; data.description.includes(term));\n        }\n        if (isTitleMatch) {\n          titleMatches.push(data);\n        } else if (isDescMatch) {\n          descMatches.push(data);\n        }\n      });\n\n      if (searchTerms.length === 1) {\n        const term = searchTerms[0];\n        titleMatches.sort(\n          (a, b) =&gt; a.name.indexOf(term) - b.name.indexOf(term),\n        );\n        descMatches.sort(\n          (a, b) =&gt; a.description.indexOf(term) - b.description.indexOf(term),\n        );\n      }\n\n      itemsToProcess = [];\n      titleMatches.forEach((data) =&gt; {\n        visibleCount++;\n        itemsToProcess.push({ element: data.element, visible: true });\n      });\n      descMatches.forEach((data) =&gt; {\n        visibleCount++;\n        itemsToProcess.push({ element: data.element, visible: true });\n      });\n      optionsData.forEach((data) =&gt; {\n        if (!itemsToProcess.some((item) =&gt; item.element === data.element)) {\n          itemsToProcess.push({ element: data.element, visible: false });\n        }\n      });\n\n      // Reorder DOM so all title matches, then desc matches, then hidden\n      const fragment = document.createDocumentFragment();\n      itemsToProcess.forEach((item) =&gt; {\n        fragment.appendChild(item.element);\n      });\n      optionsContainer.appendChild(fragment);\n\n      filterResults.visibleCount = visibleCount;\n      pendingRender = requestAnimationFrame(processNextChunk);\n    }\n\n    // Use different debounce times for desktop vs mobile\n    const debouncedFilter = debounce(filterOptions, isMobile ? 200 : 100);\n\n    // Set up event listeners\n    optionsFilter.addEventListener(\&quot;input\&quot;, debouncedFilter);\n    optionsFilter.addEventListener(\&quot;change\&quot;, filterOptions);\n\n    // Allow clearing with Escape key\n    optionsFilter.addEventListener(\&quot;keydown\&quot;, function (e) {\n      if (e.key === \&quot;Escape\&quot;) {\n        optionsFilter.value = \&quot;\&quot;;\n        filterOptions();\n      }\n    });\n\n    // Handle visibility changes\n    document.addEventListener(\&quot;visibilitychange\&quot;, function () {\n      if (!document.hidden &amp;&amp; optionsFilter.value) {\n        filterOptions();\n      }\n    });\n\n    // Initially trigger filter if there\&#39;s a value\n    if (optionsFilter.value) {\n      filterOptions();\n    }\n\n    // Pre-calculate heights for smoother scrolling\n    if (isMobile &amp;&amp; totalCount &gt; 50) {\n      requestIdleCallback(() =&gt; {\n        const sampleOption = options[0];\n        if (sampleOption) {\n          const height = sampleOption.offsetHeight;\n          if (height &gt; 0) {\n            options.forEach((opt) =&gt; {\n              opt.style.containIntrinsicSize = `0 ${height}px`;\n            });\n          }\n        }\n      });\n    }\n  }\n});\n&quot;;</code></pre></section></div></main></body></html>