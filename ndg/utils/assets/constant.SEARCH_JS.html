<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `SEARCH_JS` constant in crate `ndg`."><title>SEARCH_JS in ndg::utils::assets - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="ndg" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.0-nightly (07bdbaedc 2025-11-19)" data-channel="nightly" data-search-js="search-680b2199.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">SEARCH_JS</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../ndg/index.html">ndg</a><span class="version">2.4.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In ndg::<wbr>utils::<wbr>assets</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">ndg</a>::<wbr><a href="../index.html">utils</a>::<wbr><a href="index.html">assets</a></div><h1>Constant <span class="constant">SEARCH_<wbr>JS</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/ndg/utils/assets.rs.html#10">Source</a> </span></div><pre class="rust item-decl"><code>const SEARCH_JS: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;if (!window.searchNamespace) window.searchNamespace = {};\n\nclass SearchEngine {\n  constructor() {\n    this.documents = [];\n    this.tokenMap = new Map();\n    this.isLoaded = false;\n    this.loadError = false;\n    this.useWebWorker = typeof Worker !== \&#39;undefined\&#39; &amp;&amp; searchWorker !== null;\n    this.fullDocuments = null; // for lazy loading\n  }\n\n  // Load search data from JSON\n  async loadData() {\n    if (this.isLoaded &amp;&amp; !this.loadError) return;\n\n    // Clear previous error state on retry\n    this.loadError = false;\n\n    try {\n      // Load JSON data, try multiple possible paths\n      // FIXME: There is only one possible path for now, and this search data is guaranteed\n      // to generate at this location, but we\&#39;ll want to extend this in the future.\n      const possiblePaths = [\&quot;/assets/search-data.json\&quot;];\n\n      let response = null;\n      let usedPath = \&quot;\&quot;;\n\n      for (const path of possiblePaths) {\n        try {\n          const testResponse = await fetch(path);\n          if (testResponse.ok) {\n            response = testResponse;\n            usedPath = path;\n            break;\n          }\n        } catch (e) {\n          // Continue to next path\n        }\n      }\n\n      if (!response) {\n        throw new Error(\&quot;Search data file not found at any expected location\&quot;);\n      }\n\n      console.log(`Loading search data from: ${usedPath}`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // Use optimized JSON parsing for large files\n      const documents = await this.parseLargeJSON(response);\n      if (!Array.isArray(documents)) {\n        throw new Error(\&quot;Invalid search data format\&quot;);\n      }\n\n      this.initializeFromDocuments(documents);\n      this.isLoaded = true;\n      console.log(`Loaded ${documents.length} documents for search`);\n    } catch (error) {\n      console.error(\&quot;Error loading search data:\&quot;, error);\n      this.documents = [];\n      this.tokenMap.clear();\n      this.loadError = true;\n    }\n  }\n\n  // Initialize from documents array\n  async initializeFromDocuments(documents) {\n    if (!Array.isArray(documents)) {\n      console.error(\&quot;Invalid documents format:\&quot;, typeof documents);\n      this.documents = [];\n    } else {\n      this.documents = documents;\n      console.log(`Initialized with ${documents.length} documents`);\n    }\n    try {\n      await this.buildTokenMap();\n    } catch (error) {\n      console.error(\&quot;Error building token map:\&quot;, error);\n    }\n  }\n\n  // Initialize from search index structure\n  initializeIndex(indexData) {\n    this.documents = indexData.documents || [];\n    this.tokenMap = new Map(Object.entries(indexData.tokenMap || {}));\n  }\n\n  // Build token map\n  // This is helpful for faster searching with progressive loading\n  buildTokenMap() {\n    return new Promise((resolve, reject) =&gt; {\n      this.tokenMap.clear();\n\n      if (!Array.isArray(this.documents)) {\n        console.error(\&quot;No documents to build token map\&quot;);\n        resolve();\n        return;\n      }\n\n      const totalDocs = this.documents.length;\n      let processedDocs = 0;\n\n      try {\n        // Process in chunks to avoid blocking UI\n        const processChunk = (startIndex, chunkSize) =&gt; {\n          try {\n            const endIndex = Math.min(startIndex + chunkSize, totalDocs);\n\n            for (let i = startIndex; i &lt; endIndex; i++) {\n              const doc = this.documents[i];\n              if (!doc || typeof doc.title !== \&#39;string\&#39; || typeof doc.content !== \&#39;string\&#39;) {\n                console.warn(`Invalid document at index ${i}:`, doc);\n                continue;\n              }\n\n              const tokens = this.tokenize(doc.title + \&quot; \&quot; + doc.content);\n              tokens.forEach(token =&gt; {\n                if (!this.tokenMap.has(token)) {\n                  this.tokenMap.set(token, []);\n                }\n                this.tokenMap.get(token).push(i);\n              });\n\n              processedDocs++;\n            }\n\n            // Update progress and yield control\n            if (endIndex &lt; totalDocs) {\n              setTimeout(() =&gt; processChunk(endIndex, chunkSize), 0);\n            } else {\n              console.log(`Built token map with ${this.tokenMap.size} unique tokens from ${processedDocs} documents`);\n              resolve();\n            }\n          } catch (error) {\n            reject(error);\n          }\n        };\n\n        // Start processing with small chunks\n        processChunk(0, 100);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  // Tokenize text into searchable terms\n  tokenize(text) {\n    const tokens = new Set();\n    const words = text.toLowerCase().match(/\\b[a-zA-Z0-9_-]+\\b/g) || [];\n\n    words.forEach(word =&gt; {\n      if (word.length &gt; 2) {\n        tokens.add(word);\n      }\n    });\n\n    return Array.from(tokens);\n  }\n\n  // Advanced search with ranking\n  async search(query, limit = 10) {\n    if (!query.trim()) return [];\n\n    // Wait for data to be loaded\n    if (!this.isLoaded) {\n      await this.loadData();\n    }\n\n    if (!this.isLoaded || this.documents.length === 0) {\n      console.log(\&quot;Search data not available\&quot;);\n      return [];\n    }\n\n    const searchTerms = this.tokenize(query);\n    if (searchTerms.length === 0) return [];\n\n    // Fallback to basic search if token map is empty\n    if (this.tokenMap.size === 0) {\n      return this.fallbackSearch(query, limit);\n    }\n\n    // Use Web Worker for large datasets to avoid blocking UI\n    if (this.useWebWorker &amp;&amp; this.documents.length &gt; 1000) {\n      return await this.searchWithWorker(query, limit);\n    }\n\n    // For very large datasets, implement lazy loading with candidate docIds\n    if (this.documents.length &gt; 10000) {\n      const candidateDocIds = new Set();\n      searchTerms.forEach(term =&gt; {\n        const docIds = this.tokenMap.get(term) || [];\n        docIds.forEach(id =&gt; candidateDocIds.add(id));\n      });\n      const docIds = Array.from(candidateDocIds);\n      return await this.lazyLoadDocuments(docIds, limit);\n    }\n\n    const docScores = new Map();\n\n    searchTerms.forEach(term =&gt; {\n      const docIds = this.tokenMap.get(term) || [];\n      docIds.forEach(docId =&gt; {\n        const doc = this.documents[docId];\n        if (!doc) return;\n\n        const currentScore = docScores.get(docId) || 0;\n\n        // Calculate score based on term position and importance\n        let score = 1;\n\n        // Title matches get higher score\n        if (doc.title.toLowerCase().includes(term)) {\n          score += 10;\n          // Exact title match gets even higher score\n          if (doc.title.toLowerCase() === term) {\n            score += 20;\n          }\n        }\n\n        // Content matches\n        if (doc.content.toLowerCase().includes(term)) {\n          score += 2;\n        }\n\n        // Boost for multiple term matches\n        docScores.set(docId, currentScore + score);\n      });\n    });\n\n    // Sort by score and return top results\n    const scoredResults = Array.from(docScores.entries())\n      .sort((a, b) =&gt; b[1] - a[1])\n      .slice(0, limit);\n\n    return scoredResults\n      .map(([docId, score]) =&gt; ({\n        ...this.documents[docId],\n        score\n      }));\n  }\n\n  // Generate search preview with highlighting\n  generatePreview(content, query, maxLength = 150) {\n    const lowerContent = content.toLowerCase();\n\n    let bestIndex = -1;\n    let bestScore = 0;\n    let bestMatch = \&quot;\&quot;;\n\n    // Find the best match position\n    const queryWords = this.tokenize(query);\n    queryWords.forEach(word =&gt; {\n      const index = lowerContent.indexOf(word);\n      if (index !== -1) {\n        const score = word.length; // longer words get higher priority\n        if (score &gt; bestScore) {\n          bestScore = score;\n          bestIndex = index;\n          bestMatch = word;\n        }\n      }\n    });\n\n    if (bestIndex === -1) {\n      return this.escapeHtml(content.slice(0, maxLength)) + \&quot;...\&quot;;\n    }\n\n    const start = Math.max(0, bestIndex - 50);\n    const end = Math.min(content.length, bestIndex + bestMatch.length + 50);\n    let preview = content.slice(start, end);\n\n    if (start &gt; 0) preview = \&quot;...\&quot; + preview;\n    if (end &lt; content.length) preview += \&quot;...\&quot;;\n\n    // Escape HTML first, then highlight\n    preview = this.escapeHtml(preview);\n    preview = this.highlightTerms(preview, queryWords);\n\n    return preview;\n  }\n\n  // Escape HTML to prevent XSS\n  escapeHtml(text) {\n    const div = document.createElement(\&#39;div\&#39;);\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  // Highlight search terms in text\n  highlightTerms(text, terms) {\n    let highlighted = text;\n\n    // Sort terms by length (longer first) to avoid overlapping highlights\n    const sortedTerms = [...terms].sort((a, b) =&gt; b.length - a.length);\n\n    sortedTerms.forEach(term =&gt; {\n      const regex = new RegExp(`(${this.escapeRegex(term)})`, \&#39;gi\&#39;);\n      highlighted = highlighted.replace(regex, \&#39;&lt;mark&gt;$1&lt;/mark&gt;\&#39;);\n    });\n\n    return highlighted;\n  }\n\n  // Web Worker search for large datasets\n  async searchWithWorker(query, limit) {\n    return new Promise((resolve, reject) =&gt; {\n      const messageId = `search_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      const timeout = setTimeout(() =&gt; {\n        cleanup();\n        reject(new Error(\&#39;Web Worker search timeout\&#39;));\n      }, 5000); // 5 second timeout\n\n      const handleMessage = (e) =&gt; {\n        if (e.data.messageId !== messageId) return;\n\n        clearTimeout(timeout);\n        cleanup();\n\n        if (e.data.type === \&#39;results\&#39;) {\n          resolve(e.data.data);\n        } else if (e.data.type === \&#39;error\&#39;) {\n          reject(new Error(e.data.error || \&#39;Unknown worker error\&#39;));\n        }\n      };\n\n      const handleError = (error) =&gt; {\n        clearTimeout(timeout);\n        cleanup();\n        reject(error);\n      };\n\n      const cleanup = () =&gt; {\n        searchWorker.removeEventListener(\&#39;message\&#39;, handleMessage);\n        searchWorker.removeEventListener(\&#39;error\&#39;, handleError);\n      };\n\n      searchWorker.addEventListener(\&#39;message\&#39;, handleMessage);\n      searchWorker.addEventListener(\&#39;error\&#39;, handleError);\n\n      searchWorker.postMessage({\n        messageId,\n        type: \&#39;search\&#39;,\n        data: { documents: this.documents, query, limit }\n      });\n    });\n  }\n\n  // Escape regex special characters\n  escapeRegex(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \&#39;\\\\$&amp;\&#39;);\n  }\n\n  // Optimized JSON parser for large files\n  async parseLargeJSON(response) {\n    const contentLength = response.headers.get(\&#39;content-length\&#39;);\n\n    // For small files, use regular JSON parsing\n    if (!contentLength || parseInt(contentLength) &lt; 1024 * 1024) { // &lt; 1MB\n      return await response.json();\n    }\n\n    // For large files, use streaming approach\n    console.log(`Large search file detected (${contentLength} bytes), using streaming parser`);\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder(\&quot;utf-8\&quot;);\n    let buffer = \&quot;\&quot;;\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      buffer += decoder.decode(value, { stream: true });\n\n      // Process in chunks to avoid blocking main thread\n      if (buffer.length &gt; 100 * 1024) { // 100KB chunks\n        await new Promise(resolve =&gt; setTimeout(resolve, 0));\n      }\n    }\n\n    return JSON.parse(buffer);\n  }\n\n  // Lazy loading for search results\n  async lazyLoadDocuments(docIds, limit = 10) {\n    if (!this.fullDocuments) {\n      // Store full documents separately for memory efficiency\n      this.fullDocuments = this.documents;\n      // Create lightweight index documents\n      this.documents = this.documents.map(doc =&gt; ({\n        id: doc.id,\n        title: doc.title,\n        path: doc.path\n      }));\n    }\n\n    return docIds.slice(0, limit).map(id =&gt; this.fullDocuments[id]);\n  }\n\n  // Fallback search method (simple string matching)\n  fallbackSearch(query, limit = 10) {\n    const lowerQuery = query.toLowerCase();\n    const results = this.documents\n      .map(doc =&gt; {\n        const titleMatch = doc.title.toLowerCase().indexOf(lowerQuery);\n        const contentMatch = doc.content.toLowerCase().indexOf(lowerQuery);\n        let score = 0;\n\n        if (titleMatch !== -1) {\n          score += 10;\n          if (doc.title.toLowerCase() === lowerQuery) {\n            score += 20;\n          }\n        }\n        if (contentMatch !== -1) {\n          score += 2;\n        }\n\n        return { doc, score, titleMatch, contentMatch };\n      })\n      .filter(item =&gt; item.score &gt; 0)\n      .sort((a, b) =&gt; {\n        if (a.score !== b.score) return b.score - a.score;\n        if (a.titleMatch !== b.titleMatch) return a.titleMatch - b.titleMatch;\n        return a.contentMatch - b.contentMatch;\n      })\n      .slice(0, limit)\n      .map(item =&gt; ({ ...item.doc, score: item.score }));\n\n    return results;\n  }\n}\n\n// Web Worker for background search processing\n// This is CLEARLY the best way to do it lmao.\n// Create Web Worker if supported\nlet searchWorker = null;\nif (typeof Worker !== \&#39;undefined\&#39;) {\n  try {\n    searchWorker = new Worker(\&#39;/assets/search-worker.js\&#39;);\n    console.log(\&#39;Web Worker initialized for background search\&#39;);\n  } catch (error) {\n    console.warn(\&#39;Web Worker creation failed, using main thread:\&#39;, error);\n  }\n}\n\n// Global search engine instance\nwindow.searchNamespace.engine = new SearchEngine();\n\n// Mobile search timeout for debouncing\nlet mobileSearchTimeout = null;\n\n// Legacy search for backward compatibility\n// This could be removed, but I\&#39;m emotionally attached to it\n// and it could be used as a fallback.\nfunction filterSearchResults(data, searchTerm, limit = 10) {\n  return data\n    .filter(\n      (doc) =&gt;\n        doc.title.toLowerCase().includes(searchTerm) ||\n        doc.content.toLowerCase().includes(searchTerm),\n    )\n    .slice(0, limit);\n}\n\ndocument.addEventListener(\&quot;DOMContentLoaded\&quot;, function() {\n  // Initialize search engine immediately\n  window.searchNamespace.engine.loadData().then(() =&gt; {\n    console.log(\&quot;Search data loaded successfully\&quot;);\n  }).catch(error =&gt; {\n    console.error(\&quot;Failed to initialize search:\&quot;, error);\n  });\n\n  // Search page specific functionality\n  const searchPageInput = document.getElementById(\&quot;search-page-input\&quot;);\n  if (searchPageInput) {\n    // Set up event listener\n    searchPageInput.addEventListener(\&quot;input\&quot;, function() {\n      performSearch(this.value);\n    });\n\n    // Perform search if URL has query\n    const params = new URLSearchParams(window.location.search);\n    const query = params.get(\&quot;q\&quot;);\n    if (query) {\n      searchPageInput.value = query;\n      performSearch(query);\n    }\n  }\n\n  // Desktop Sidebar Toggle\n  const searchInput = document.getElementById(\&quot;search-input\&quot;);\n  if (searchInput) {\n    const searchResults = document.getElementById(\&quot;search-results\&quot;);\n\n    searchInput.addEventListener(\&quot;input\&quot;, async function() {\n      const searchTerm = this.value.trim();\n\n      if (searchTerm.length &lt; 2) {\n        searchResults.innerHTML = \&quot;\&quot;;\n        searchResults.style.display = \&quot;none\&quot;;\n        return;\n      }\n\n      // Show loading state\n      searchResults.innerHTML = \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;Loading...&lt;/div&gt;\&#39;;\n      searchResults.style.display = \&quot;block\&quot;;\n\n      try {\n        const results = await window.searchNamespace.engine.search(searchTerm, 8);\n\n        if (results.length &gt; 0) {\n          searchResults.innerHTML = results\n            .map(\n              (doc) =&gt; {\n                const highlightedTitle = window.searchNamespace.engine.highlightTerms(\n                  doc.title,\n                  window.searchNamespace.engine.tokenize(searchTerm)\n                );\n                return `\n                          &lt;div class=\&quot;search-result-item\&quot;&gt;\n                              &lt;a href=\&quot;${doc.path}\&quot;&gt;${highlightedTitle}&lt;/a&gt;\n                          &lt;/div&gt;\n                      `;\n              },\n            )\n            .join(\&quot;\&quot;);\n          searchResults.style.display = \&quot;block\&quot;;\n        } else {\n          searchResults.innerHTML =\n            \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;No results found&lt;/div&gt;\&#39;;\n          searchResults.style.display = \&quot;block\&quot;;\n        }\n      } catch (error) {\n        console.error(\&quot;Search error:\&quot;, error);\n        searchResults.innerHTML =\n          \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;Search unavailable&lt;/div&gt;\&#39;;\n        searchResults.style.display = \&quot;block\&quot;;\n      }\n    });\n\n    // Hide results when clicking outside\n    document.addEventListener(\&quot;click\&quot;, function(event) {\n      if (\n        !searchInput.contains(event.target) &amp;&amp;\n        !searchResults.contains(event.target)\n      ) {\n        searchResults.style.display = \&quot;none\&quot;;\n      }\n    });\n\n    // Focus search when pressing slash key\n    document.addEventListener(\&quot;keydown\&quot;, function(event) {\n      if (event.key === \&quot;/\&quot; &amp;&amp; document.activeElement !== searchInput) {\n        event.preventDefault();\n        searchInput.focus();\n      }\n    });\n  }\n\n  // Mobile search functionality\n  // This detects mobile viewport and adds click behavior\n  function isMobile() {\n    return window.innerWidth &lt;= 800;\n  }\n\n  if (searchInput) {\n    // Add mobile search behavior\n    searchInput.addEventListener(\&quot;click\&quot;, function(e) {\n      if (isMobile()) {\n        e.preventDefault();\n        e.stopPropagation();\n        openMobileSearch();\n      }\n      // On desktop, let the normal click behavior work (focus the input)\n    });\n\n    // Prevent typing on mobile (input should only open popup)\n    searchInput.addEventListener(\&quot;keydown\&quot;, function(e) {\n      if (isMobile()) {\n        e.preventDefault();\n        openMobileSearch();\n      }\n    });\n  }\n\n  // Mobile search popup functionality\n  let mobileSearchPopup = document.getElementById(\&quot;mobile-search-popup\&quot;);\n  let mobileSearchInput = document.getElementById(\&quot;mobile-search-input\&quot;);\n  let mobileSearchResults = document.getElementById(\&quot;mobile-search-results\&quot;);\n  const closeMobileSearchBtn = document.getElementById(\&quot;close-mobile-search\&quot;);\n\n  function openMobileSearch() {\n    if (mobileSearchPopup) {\n      mobileSearchPopup.classList.add(\&quot;active\&quot;);\n      // Focus the input after a small delay to ensure the popup is visible\n      setTimeout(() =&gt; {\n        if (mobileSearchInput) {\n          mobileSearchInput.focus();\n        }\n      }, 100);\n    }\n  }\n\n  function closeMobileSearch() {\n    if (mobileSearchPopup) {\n      mobileSearchPopup.classList.remove(\&quot;active\&quot;);\n      if (mobileSearchInput) {\n        mobileSearchInput.value = \&quot;\&quot;;\n      }\n      if (mobileSearchResults) {\n        mobileSearchResults.innerHTML = \&quot;\&quot;;\n        mobileSearchResults.style.display = \&quot;none\&quot;;\n      }\n    }\n  }\n\n  if (closeMobileSearchBtn) {\n    closeMobileSearchBtn.addEventListener(\&quot;click\&quot;, closeMobileSearch);\n  }\n\n  // Close mobile search when clicking outside\n  document.addEventListener(\&quot;click\&quot;, function(event) {\n    if (\n      mobileSearchPopup &amp;&amp;\n      mobileSearchPopup.classList.contains(\&quot;active\&quot;) &amp;&amp;\n      !mobileSearchPopup.contains(event.target) &amp;&amp;\n      !searchInput.contains(event.target)\n    ) {\n      closeMobileSearch();\n    }\n  });\n\n  // Close mobile search on escape key\n  document.addEventListener(\&quot;keydown\&quot;, function(event) {\n    if (\n      event.key === \&quot;Escape\&quot; &amp;&amp;\n      mobileSearchPopup &amp;&amp;\n      mobileSearchPopup.classList.contains(\&quot;active\&quot;)\n    ) {\n      closeMobileSearch();\n    }\n  });\n\n  // Mobile search input\n  if (mobileSearchInput &amp;&amp; mobileSearchResults) {\n    function handleMobileSearchInput() {\n      clearTimeout(mobileSearchTimeout);\n      const searchTerm = mobileSearchInput.value.trim();\n      if (searchTerm.length &lt; 2) {\n        mobileSearchResults.innerHTML = \&quot;\&quot;;\n        mobileSearchResults.style.display = \&quot;none\&quot;;\n        return;\n      }\n\n      mobileSearchTimeout = setTimeout(async () =&gt; {\n        // Verify the input still matches before proceeding\n        if (mobileSearchInput.value.trim() !== searchTerm) return;\n\n        // Show loading state\n        mobileSearchResults.innerHTML = \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;Loading...&lt;/div&gt;\&#39;;\n        mobileSearchResults.style.display = \&quot;block\&quot;;\n\n        try {\n          const results = await window.searchNamespace.engine.search(searchTerm, 8);\n          // Verify again after async operation\n          if (mobileSearchInput.value.trim() !== searchTerm) return;\n\n          if (results.length &gt; 0) {\n            mobileSearchResults.innerHTML = results\n              .map(\n                (doc) =&gt; {\n                  const highlightedTitle = window.searchNamespace.engine.highlightTerms(\n                    doc.title,\n                    window.searchNamespace.engine.tokenize(searchTerm)\n                  );\n                  return `\n                    &lt;div class=\&quot;search-result-item\&quot;&gt;\n                        &lt;a href=\&quot;${doc.path}\&quot;&gt;${highlightedTitle}&lt;/a&gt;\n                    &lt;/div&gt;\n                `;\n                },\n              )\n              .join(\&quot;\&quot;);\n            mobileSearchResults.style.display = \&quot;block\&quot;;\n          } else {\n            mobileSearchResults.innerHTML =\n              \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;No results found&lt;/div&gt;\&#39;;\n            mobileSearchResults.style.display = \&quot;block\&quot;;\n          }\n        } catch (error) {\n          console.error(\&quot;Mobile search error:\&quot;, error);\n          // Verify once more\n          if (mobileSearchInput.value.trim() !== searchTerm) return;\n          mobileSearchResults.innerHTML =\n            \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;Search unavailable&lt;/div&gt;\&#39;;\n          mobileSearchResults.style.display = \&quot;block\&quot;;\n        }\n      }, 300);\n    }\n\n    mobileSearchInput.addEventListener(\&quot;input\&quot;, handleMobileSearchInput);\n  }\n\n  // Handle window resize to update mobile behavior\n  window.addEventListener(\&quot;resize\&quot;, function() {\n    // Close mobile search if window is resized to desktop size\n    if (\n      !isMobile() &amp;&amp;\n      mobileSearchPopup &amp;&amp;\n      mobileSearchPopup.classList.contains(\&quot;active\&quot;)\n    ) {\n      closeMobileSearch();\n    }\n  });\n});\n\nasync function performSearch(query) {\n  query = query.trim();\n  const resultsContainer = document.getElementById(\&quot;search-page-results\&quot;);\n\n  if (query.length &lt; 2) {\n    resultsContainer.innerHTML =\n      \&quot;&lt;p&gt;Please enter at least 2 characters to search&lt;/p&gt;\&quot;;\n    return;\n  }\n\n  // Show loading state\n  resultsContainer.innerHTML = \&quot;&lt;p&gt;Searching...&lt;/p&gt;\&quot;;\n\n  try {\n    const results = await window.searchNamespace.engine.search(query, 50);\n\n    // Display results\n    if (results.length &gt; 0) {\n      let html = \&#39;&lt;ul class=\&quot;search-results-list\&quot;&gt;\&#39;;\n      const queryTerms = window.searchNamespace.engine.tokenize(query);\n\n      for (const result of results) {\n        const highlightedTitle = window.searchNamespace.engine.highlightTerms(result.title, queryTerms);\n        const preview = window.searchNamespace.engine.generatePreview(result.content, query);\n        html += `&lt;li class=\&quot;search-result-item\&quot;&gt;\n          &lt;a href=\&quot;${result.path}\&quot;&gt;\n            &lt;div class=\&quot;search-result-title\&quot;&gt;${highlightedTitle}&lt;/div&gt;\n            &lt;div class=\&quot;search-result-preview\&quot;&gt;${preview}&lt;/div&gt;\n          &lt;/a&gt;\n        &lt;/li&gt;`;\n      }\n      html += \&quot;&lt;/ul&gt;\&quot;;\n      resultsContainer.innerHTML = html;\n    } else {\n      resultsContainer.innerHTML = \&quot;&lt;p&gt;No results found&lt;/p&gt;\&quot;;\n    }\n\n    // Update URL with query\n    const url = new URL(window.location.href);\n    url.searchParams.set(\&quot;q\&quot;, query);\n    window.history.replaceState({}, \&quot;\&quot;, url.toString());\n  } catch (error) {\n    console.error(\&quot;Search error:\&quot;, error);\n    resultsContainer.innerHTML = \&quot;&lt;p&gt;Search temporarily unavailable&lt;/p&gt;\&quot;;\n  }\n}\n&quot;;</code></pre></section></div></main></body></html>