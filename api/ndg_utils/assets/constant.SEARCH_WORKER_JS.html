<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `SEARCH_WORKER_JS` constant in crate `ndg_utils`."><title>SEARCH_WORKER_JS in ndg_utils::assets - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="ndg_utils" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (873b4beb0 2026-02-15)" data-channel="nightly" data-search-js="search-63369b7b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../static.files/storage-41dd4d93.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5013f961.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">SEARCH_WORKER_JS</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../ndg_utils/index.html">ndg_<wbr>utils</a><span class="version">2.6.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In ndg_<wbr>utils::<wbr>assets</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">ndg_utils</a>::<wbr><a href="index.html">assets</a></div><h1>Constant <span class="constant">SEARCH_<wbr>WORKER_<wbr>JS</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/ndg_utils/assets.rs.html#13-14">Source</a> </span></div><pre class="rust item-decl"><code>const SEARCH_WORKER_JS: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;const isWordBoundary = (char) =&gt;\n  /[A-Z]/.test(char) || /[-_\\/.]/.test(char) || /\\s/.test(char);\n\nconst isCaseTransition = (prev, curr) =&gt; {\n  const prevIsUpper = prev.toLowerCase() !== prev;\n  const currIsUpper = curr.toLowerCase() !== curr;\n  return (\n    prevIsUpper &amp;&amp; currIsUpper &amp;&amp; prev.toLowerCase() !== curr.toLowerCase()\n  );\n};\n\nconst findBestSubsequenceMatch = (query, target) =&gt; {\n  const n = query.length;\n  const m = target.length;\n\n  if (n === 0 || m === 0) return null;\n\n  const positions = [];\n\n  const memo = new Map();\n  const key = (qIdx, tIdx, gap) =&gt; `${qIdx}:${tIdx}:${gap}`;\n\n  const findBest = (qIdx, tIdx, currentGap) =&gt; {\n    if (qIdx === n) {\n      return { done: true, positions: [...positions], gap: currentGap };\n    }\n\n    const memoKey = key(qIdx, tIdx, currentGap);\n    if (memo.has(memoKey)) {\n      return memo.get(memoKey);\n    }\n\n    let bestResult = null;\n\n    for (let i = tIdx; i &lt; m; i++) {\n      if (target[i] === query[qIdx]) {\n        positions.push(i);\n        const gap = qIdx === 0 ? 0 : i - positions[positions.length - 2] - 1;\n        const newGap = currentGap + gap;\n\n        if (newGap &gt; m) {\n          positions.pop();\n          continue;\n        }\n\n        const result = findBest(qIdx + 1, i + 1, newGap);\n        positions.pop();\n\n        if (result &amp;&amp; (!bestResult || result.gap &lt; bestResult.gap)) {\n          bestResult = result;\n          if (result.gap === 0) break;\n        }\n      }\n    }\n\n    memo.set(memoKey, bestResult);\n    return bestResult;\n  };\n\n  const result = findBest(0, 0, 0);\n  if (!result) return null;\n\n  const consecutive = (() =&gt; {\n    let c = 1;\n    for (let i = 1; i &lt; result.positions.length; i++) {\n      if (result.positions[i] === result.positions[i - 1] + 1) {\n        c++;\n      }\n    }\n    return c;\n  })();\n\n  return {\n    positions: result.positions,\n    consecutive,\n    score: calculateMatchScore(query, target, result.positions, consecutive),\n  };\n};\n\nconst calculateMatchScore = (query, target, positions, consecutive) =&gt; {\n  const n = positions.length;\n  const m = target.length;\n\n  if (n === 0) return 0;\n\n  let score = 1.0;\n\n  const startBonus = (m - positions[0]) / m;\n  score += startBonus * 0.5;\n\n  let gapPenalty = 0;\n  for (let i = 1; i &lt; n; i++) {\n    const gap = positions[i] - positions[i - 1] - 1;\n    if (gap &gt; 0) {\n      gapPenalty += Math.min(gap / m, 1.0) * 0.3;\n    }\n  }\n  score -= gapPenalty;\n\n  const consecutiveBonus = consecutive / n;\n  score += consecutiveBonus * 0.3;\n\n  let boundaryBonus = 0;\n  for (let i = 0; i &lt; n; i++) {\n    const char = target[positions[i]];\n    if (i === 0 || isWordBoundary(char)) {\n      boundaryBonus += 0.05;\n    }\n    if (i &gt; 0) {\n      const prevChar = target[positions[i - 1]];\n      if (isCaseTransition(prevChar, char)) {\n        boundaryBonus += 0.03;\n      }\n    }\n  }\n  score = Math.min(1.0, score + boundaryBonus);\n\n  const lengthPenalty = Math.abs(query.length - n) / Math.max(query.length, m);\n  score -= lengthPenalty * 0.2;\n\n  return Math.max(0, Math.min(1.0, score));\n};\n\nconst fuzzyMatch = (query, target) =&gt; {\n  const lowerQuery = query.toLowerCase();\n  const lowerTarget = target.toLowerCase();\n\n  if (lowerQuery.length === 0) return null;\n  if (lowerTarget.length === 0) return null;\n\n  if (lowerTarget === lowerQuery) {\n    return 1.0;\n  }\n\n  if (lowerTarget.includes(lowerQuery)) {\n    const ratio = lowerQuery.length / lowerTarget.length;\n    return 0.8 + ratio * 0.2;\n  }\n\n  const match = findBestSubsequenceMatch(lowerQuery, lowerTarget);\n  if (!match) {\n    return null;\n  }\n\n  return Math.min(1.0, match.score);\n};\n\nself.onmessage = function (e) {\n  const { messageId, type, data } = e.data;\n\n  const respond = (type, data) =&gt; {\n    self.postMessage({ messageId, type, data });\n  };\n\n  const respondError = (error) =&gt; {\n    self.postMessage({\n      messageId,\n      type: \&quot;error\&quot;,\n      error: error.message || String(error),\n    });\n  };\n\n  try {\n    if (type === \&quot;tokenize\&quot;) {\n      const text = typeof data === \&quot;string\&quot; ? data : \&quot;\&quot;;\n      const words = text.toLowerCase().match(/\\b[a-zA-Z0-9_-]+\\b/g) || [];\n      const tokens = words.filter((word) =&gt; word.length &gt; 2);\n      const uniqueTokens = Array.from(new Set(tokens));\n      respond(\&quot;tokens\&quot;, uniqueTokens);\n    } else if (type === \&quot;search\&quot;) {\n      const { query, limit = 10 } = data;\n\n      if (!query || typeof query !== \&quot;string\&quot;) {\n        respond(\&quot;results\&quot;, []);\n        return;\n      }\n\n      const rawQuery = query.toLowerCase();\n      const text = typeof query === \&quot;string\&quot; ? query : \&quot;\&quot;;\n      const words = text.toLowerCase().match(/\\b[a-zA-Z0-9_-]+\\b/g) || [];\n      const searchTerms = words.filter((word) =&gt; word.length &gt; 2);\n\n      let documents = [];\n      if (typeof data.documents === \&quot;string\&quot;) {\n        documents = JSON.parse(data.documents);\n      } else if (Array.isArray(data.documents)) {\n        documents = data.documents;\n      } else if (typeof data.transferables === \&quot;string\&quot;) {\n        documents = JSON.parse(data.transferables);\n      }\n\n      if (!Array.isArray(documents) || documents.length === 0) {\n        respond(\&quot;results\&quot;, []);\n        return;\n      }\n\n      const useFuzzySearch = rawQuery.length &gt;= 3;\n\n      if (searchTerms.length === 0 &amp;&amp; rawQuery.length &lt; 3) {\n        respond(\&quot;results\&quot;, []);\n        return;\n      }\n\n      const pageMatches = new Map();\n\n      // Pre-compute lower-case strings for each document\n      const processedDocs = documents.map((doc, docId) =&gt; {\n        const title = typeof doc.title === \&quot;string\&quot; ? doc.title : \&quot;\&quot;;\n        const content = typeof doc.content === \&quot;string\&quot; ? doc.content : \&quot;\&quot;;\n\n        return {\n          docId,\n          doc,\n          lowerTitle: title.toLowerCase(),\n          lowerContent: content.toLowerCase(),\n        };\n      });\n\n      // First pass: Score pages with fuzzy matching\n      processedDocs.forEach(({ docId, doc, lowerTitle, lowerContent }) =&gt; {\n        let match = pageMatches.get(docId);\n        if (!match) {\n          match = { doc, pageScore: 0, matchingAnchors: [] };\n          pageMatches.set(docId, match);\n        }\n\n        if (useFuzzySearch) {\n          const fuzzyTitleScore = fuzzyMatch(rawQuery, lowerTitle);\n          if (fuzzyTitleScore !== null) {\n            match.pageScore += fuzzyTitleScore * 100;\n          }\n\n          const fuzzyContentScore = fuzzyMatch(rawQuery, lowerContent);\n          if (fuzzyContentScore !== null) {\n            match.pageScore += fuzzyContentScore * 30;\n          }\n        }\n\n        // Token-based exact matching\n        searchTerms.forEach((term) =&gt; {\n          if (lowerTitle.includes(term)) {\n            match.pageScore += lowerTitle === term ? 20 : 10;\n          }\n          if (lowerContent.includes(term)) {\n            match.pageScore += 2;\n          }\n        });\n      });\n\n      // Second pass: Find matching anchors\n      pageMatches.forEach((match) =&gt; {\n        const doc = match.doc;\n        if (\n          !doc.anchors ||\n          !Array.isArray(doc.anchors) ||\n          doc.anchors.length === 0\n        ) {\n          return;\n        }\n\n        doc.anchors.forEach((anchor) =&gt; {\n          if (!anchor || !anchor.text) return;\n\n          const anchorText = anchor.text.toLowerCase();\n          let anchorMatches = false;\n\n          if (useFuzzySearch) {\n            const fuzzyScore = fuzzyMatch(rawQuery, anchorText);\n            if (fuzzyScore !== null &amp;&amp; fuzzyScore &gt;= 0.4) {\n              anchorMatches = true;\n            }\n          }\n\n          if (!anchorMatches) {\n            searchTerms.forEach((term) =&gt; {\n              if (anchorText.includes(term)) {\n                anchorMatches = true;\n              }\n            });\n          }\n\n          if (anchorMatches) {\n            match.matchingAnchors.push(anchor);\n          }\n        });\n      });\n\n      const results = Array.from(pageMatches.values())\n        .filter((m) =&gt; m.pageScore &gt; 5)\n        .sort((a, b) =&gt; b.pageScore - a.pageScore)\n        .slice(0, limit);\n\n      respond(\&quot;results\&quot;, results);\n    }\n  } catch (error) {\n    respondError(error);\n  }\n};\n&quot;;</code></pre></section></div></main></body></html>