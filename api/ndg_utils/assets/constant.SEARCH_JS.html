<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `SEARCH_JS` constant in crate `ndg_utils`."><title>SEARCH_JS in ndg_utils::assets - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="ndg_utils" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (b3869b94c 2026-02-23)" data-channel="nightly" data-search-js="search-63369b7b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../static.files/storage-41dd4d93.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5013f961.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">SEARCH_JS</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../ndg_utils/index.html">ndg_<wbr>utils</a><span class="version">2.6.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In ndg_<wbr>utils::<wbr>assets</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">ndg_utils</a>::<wbr><a href="index.html">assets</a></div><h1>Constant <span class="constant">SEARCH_<wbr>JS</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/ndg_utils/assets.rs.html#12">Source</a> </span></div><pre class="rust item-decl"><code>const SEARCH_JS: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;if (!window.searchNamespace) window.searchNamespace = {};\n\nclass SearchEngine {\n  constructor() {\n    this.documents = [];\n    this.tokenMap = new Map();\n    this.lowercaseCache = [];\n    this.isLoaded = false;\n    this.loadError = false;\n    this.fullDocuments = null; // for lazy loading\n    this.rootPath = window.searchNamespace?.rootPath || \&quot;\&quot;;\n    // Search configuration (loaded from search data)\n    this.config = {\n      minWordLength: 2,\n      stopwords: [],\n      boostTitle: 100.0,\n      boostContent: 30.0,\n      boostAnchor: 10.0,\n    };\n  }\n\n  // Check if we can use Web Worker\n  get useWebWorker() {\n    if (searchWorker === false) return false; // previously failed\n    const worker = initializeSearchWorker();\n    return worker !== null;\n  }\n\n  // Load search data from JSON\n  async loadData() {\n    if (this.isLoaded &amp;&amp; !this.loadError) return;\n\n    // Clear previous error state on retry\n    this.loadError = false;\n\n    try {\n      // Load JSON data, try multiple possible paths\n      // FIXME: There is only one possible path for now, and this search data is guaranteed\n      // to generate at this location, but we\&#39;ll want to extend this in the future.\n      const possiblePaths = [\n        `${this.rootPath}assets/search-data.json`,\n        \&quot;/assets/search-data.json\&quot;, // fallback for root-level sites\n      ];\n\n      let response = null;\n      let usedPath = \&quot;\&quot;;\n\n      for (const path of possiblePaths) {\n        try {\n          const testResponse = await fetch(path);\n          if (testResponse.ok) {\n            response = testResponse;\n            usedPath = path;\n            break;\n          }\n        } catch {\n          // Continue to next path\n        }\n      }\n\n      if (!response) {\n        throw new Error(\&quot;Search data file not found at any expected location\&quot;);\n      }\n\n      console.log(`Loading search data from: ${usedPath}`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const documents = await response.json();\n      if (!Array.isArray(documents)) {\n        // New format with config\n        if (documents.documents &amp;&amp; Array.isArray(documents.documents)) {\n          this.config = {\n            minWordLength: documents.min_word_length || 2,\n            stopwords: documents.stopwords || [],\n            boostTitle: documents.boost_title || 100.0,\n            boostContent: documents.boost_content || 30.0,\n            boostAnchor: documents.boost_anchor || 10.0,\n          };\n          this.initializeFromDocuments(documents.documents);\n        } else {\n          throw new Error(\&quot;Invalid search data format\&quot;);\n        }\n      } else {\n        // Legacy format - just an array of documents\n        this.initializeFromDocuments(documents);\n      }\n      this.isLoaded = true;\n      console.log(`Loaded ${documents.length} documents for search`);\n    } catch (error) {\n      console.error(\&quot;Error loading search data:\&quot;, error);\n      this.documents = [];\n      this.tokenMap.clear();\n      this.loadError = true;\n    }\n  }\n\n  // Initialize from documents array\n  async initializeFromDocuments(documents) {\n    if (!Array.isArray(documents)) {\n      console.error(\&quot;Invalid documents format:\&quot;, typeof documents);\n      this.documents = [];\n    } else {\n      this.documents = documents;\n      console.log(`Initialized with ${documents.length} documents`);\n    }\n    try {\n      await this.buildTokenMap();\n    } catch (error) {\n      console.error(\&quot;Error building token map:\&quot;, error);\n    }\n  }\n\n  // Initialize from search index structure\n  initializeIndex(indexData) {\n    this.documents = indexData.documents || [];\n    this.tokenMap = new Map(Object.entries(indexData.tokenMap || {}));\n    this.lowercaseCache = this.documents.map((doc) =&gt; ({\n      title: (doc.title || \&quot;\&quot;).toLowerCase(),\n      content: (doc.content || \&quot;\&quot;).toLowerCase(),\n    }));\n  }\n\n  // Build token map for faster searching\n  buildTokenMap() {\n    return new Promise((resolve, reject) =&gt; {\n      this.tokenMap.clear();\n\n      if (!Array.isArray(this.documents)) {\n        console.error(\&quot;No documents to build token map\&quot;);\n        resolve();\n        return;\n      }\n\n      const totalDocs = this.documents.length;\n      let processedDocs = 0;\n\n      this.lowercaseCache = [];\n\n      try {\n        // Process in chunks to avoid blocking UI\n        const processChunk = (startIndex, chunkSize) =&gt; {\n          try {\n            const endIndex = Math.min(startIndex + chunkSize, totalDocs);\n\n            for (let i = startIndex; i &lt; endIndex; i++) {\n              const doc = this.documents[i];\n              if (\n                !doc ||\n                typeof doc.title !== \&quot;string\&quot; ||\n                typeof doc.content !== \&quot;string\&quot;\n              ) {\n                console.warn(`Invalid document at index ${i}:`, doc);\n                continue;\n              }\n\n              const lowerTitle = doc.title.toLowerCase();\n              const lowerContent = doc.content.toLowerCase();\n              this.lowercaseCache[i] = {\n                title: lowerTitle,\n                content: lowerContent,\n              };\n\n              const tokens = this.tokenize(lowerTitle + \&quot; \&quot; + lowerContent);\n              tokens.forEach((token) =&gt; {\n                if (!this.tokenMap.has(token)) {\n                  this.tokenMap.set(token, []);\n                }\n                this.tokenMap.get(token).push(i);\n              });\n\n              processedDocs++;\n            }\n\n            // Update progress and yield control\n            if (endIndex &lt; totalDocs) {\n              setTimeout(() =&gt; processChunk(endIndex, chunkSize), 0);\n            } else {\n              console.log(\n                `Built token map with ${this.tokenMap.size} unique tokens from ${processedDocs} documents`,\n              );\n              resolve();\n            }\n          } catch (error) {\n            reject(error);\n          }\n        };\n\n        // Start processing with small chunks\n        processChunk(0, 100);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  isWordBoundary(char) {\n    return /[A-Z]/.test(char) || /[-_\\/.]/.test(char) || /\\s/.test(char);\n  }\n\n  isCaseTransition(prev, curr) {\n    const prevIsUpper = prev.toLowerCase() !== prev;\n    const currIsUpper = curr.toLowerCase() !== curr;\n    return (\n      prevIsUpper &amp;&amp; currIsUpper &amp;&amp; prev.toLowerCase() !== curr.toLowerCase()\n    );\n  }\n\n  fuzzyMatch(query, target) {\n    const lowerQuery = query.toLowerCase();\n    const lowerTarget = target.toLowerCase();\n\n    if (lowerQuery.length === 0) return null;\n    if (lowerTarget.length === 0) return null;\n\n    if (lowerTarget === lowerQuery) {\n      return 1.0;\n    }\n\n    if (lowerTarget.includes(lowerQuery)) {\n      const ratio = lowerQuery.length / lowerTarget.length;\n      return 0.8 + ratio * 0.2;\n    }\n\n    const matches = this.findBestSubsequenceMatch(lowerQuery, lowerTarget);\n    if (!matches) {\n      return null;\n    }\n\n    return Math.min(1.0, matches.score);\n  }\n\n  findBestSubsequenceMatch(query, target) {\n    const n = query.length;\n    const m = target.length;\n\n    if (n === 0 || m === 0) return null;\n\n    const positions = [];\n\n    const memo = new Map();\n    const key = (qIdx, tIdx) =&gt; `${qIdx}:${tIdx}`;\n\n    const findBest = (qIdx, tIdx, currentGap) =&gt; {\n      if (qIdx === n) {\n        return { done: true, positions: [...positions], gap: currentGap };\n      }\n\n      const memoKey = key(qIdx, tIdx);\n      if (memo.has(memoKey)) {\n        return memo.get(memoKey);\n      }\n\n      let bestResult = null;\n\n      for (let i = tIdx; i &lt; m; i++) {\n        if (target[i] === query[qIdx]) {\n          positions.push(i);\n          const gap = qIdx === 0 ? 0 : i - positions[positions.length - 2] - 1;\n          const newGap = currentGap + gap;\n\n          if (newGap &gt; m) {\n            positions.pop();\n            continue;\n          }\n\n          const result = findBest(qIdx + 1, i + 1, newGap);\n          positions.pop();\n\n          if (result &amp;&amp; (!bestResult || result.gap &lt; bestResult.gap)) {\n            bestResult = result;\n            if (result.gap === 0) break;\n          }\n        }\n      }\n\n      memo.set(memoKey, bestResult);\n      return bestResult;\n    };\n\n    const result = findBest(0, 0, 0);\n    if (!result) return null;\n\n    const consecutive = (() =&gt; {\n      let c = 1;\n      for (let i = 1; i &lt; result.positions.length; i++) {\n        if (result.positions[i] === result.positions[i - 1] + 1) {\n          c++;\n        }\n      }\n      return c;\n    })();\n\n    return {\n      positions: result.positions,\n      consecutive,\n      score: this.calculateMatchScore(\n        query,\n        target,\n        result.positions,\n        consecutive,\n      ),\n    };\n  }\n\n  calculateMatchScore(query, target, positions, consecutive) {\n    const n = positions.length;\n    const m = target.length;\n\n    if (n === 0) return 0;\n\n    let score = 1.0;\n\n    const startBonus = (m - positions[0]) / m;\n    score += startBonus * 0.5;\n\n    let gapPenalty = 0;\n    for (let i = 1; i &lt; n; i++) {\n      const gap = positions[i] - positions[i - 1] - 1;\n      if (gap &gt; 0) {\n        gapPenalty += Math.min(gap / m, 1.0) * 0.3;\n      }\n    }\n    score -= gapPenalty;\n\n    const consecutiveBonus = consecutive / n;\n    score += consecutiveBonus * 0.3;\n\n    let boundaryBonus = 0;\n    for (let i = 0; i &lt; n; i++) {\n      const char = target[positions[i]];\n      if (i === 0 || this.isWordBoundary(char)) {\n        boundaryBonus += 0.05;\n      }\n      if (i &gt; 0) {\n        const prevChar = target[positions[i - 1]];\n        if (this.isCaseTransition(prevChar, char)) {\n          boundaryBonus += 0.03;\n        }\n      }\n    }\n    score = Math.min(1.0, score + boundaryBonus);\n\n    const lengthPenalty =\n      Math.abs(query.length - n) / Math.max(query.length, m);\n    score -= lengthPenalty * 0.2;\n\n    return Math.max(0, Math.min(1.0, score));\n  }\n\n  tokenize(text) {\n    if (!text || typeof text !== \&quot;string\&quot;) return [];\n\n    const words = text.toLowerCase().match(/\\b[a-zA-Z0-9_-]+\\b/g) || [];\n    const stopwordsSet = new Set(\n      this.config.stopwords.map((w) =&gt; w.toLowerCase()),\n    );\n    const tokens = words.filter(\n      (word) =&gt;\n        word.length &gt;= this.config.minWordLength &amp;&amp; !stopwordsSet.has(word),\n    );\n    return Array.from(new Set(tokens));\n  }\n\n  // Advanced search with ranking\n  async search(query, limit = 10, options = {}) {\n    if (!query || typeof query !== \&quot;string\&quot; || !query.trim()) {\n      return [];\n    }\n\n    if (options.signal?.aborted) {\n      return [];\n    }\n\n    // Wait for data to be loaded\n    if (!this.isLoaded) {\n      await this.loadData();\n    }\n\n    if (options.signal?.aborted) {\n      return [];\n    }\n\n    if (!this.isLoaded || this.documents.length === 0) {\n      console.log(\&quot;Search data not available\&quot;);\n      return [];\n    }\n\n    const searchTerms = this.tokenize(query);\n    const rawQuery = query.toLowerCase();\n\n    // Require at least 2 characters for search\n    if (searchTerms.length === 0 &amp;&amp; rawQuery.length &lt; 2) {\n      return [];\n    }\n\n    const useFuzzySearch = rawQuery.length &gt;= 3;\n\n    const candidateDocIds = new Set();\n    searchTerms.forEach((term) =&gt; {\n      if (this.tokenMap.has(term)) {\n        const docIds = this.tokenMap.get(term);\n        docIds.forEach((docId) =&gt; candidateDocIds.add(docId));\n      }\n    });\n\n    if (candidateDocIds.size === 0) {\n      return [];\n    }\n\n    const pageMatches = new Map();\n    let lastCheckTime = Date.now();\n    const CHECK_INTERVAL = 16; // Check every ~16ms (one frame)\n\n    for (const docIdx of candidateDocIds) {\n      // Check for abort periodically\n      if (Date.now() - lastCheckTime &gt; CHECK_INTERVAL) {\n        if (options.signal?.aborted) {\n          return [];\n        }\n        // Yield to main thread\n        await new Promise((resolve) =&gt; setTimeout(resolve, 0));\n        lastCheckTime = Date.now();\n\n        if (options.signal?.aborted) {\n          return [];\n        }\n      }\n\n      const doc = this.documents[docIdx];\n      let match = pageMatches.get(docIdx);\n      if (!match) {\n        match = { doc, pageScore: 0, matchingAnchors: [] };\n        pageMatches.set(docIdx, match);\n      }\n\n      const cached = this.lowercaseCache?.[docIdx];\n      const lowerTitle =\n        cached?.title ??\n        (typeof doc.title === \&quot;string\&quot; ? doc.title : \&quot;\&quot;).toLowerCase();\n      const lowerContent =\n        cached?.content ??\n        (typeof doc.content === \&quot;string\&quot; ? doc.content : \&quot;\&quot;).toLowerCase();\n\n      if (useFuzzySearch) {\n        const fuzzyTitleScore = this.fuzzyMatch(rawQuery, lowerTitle);\n\n        if (fuzzyTitleScore !== null) {\n          match.pageScore += fuzzyTitleScore * this.config.boostTitle;\n        }\n\n        const fuzzyContentScore = this.fuzzyMatch(rawQuery, lowerContent);\n\n        if (fuzzyContentScore !== null) {\n          match.pageScore += fuzzyContentScore * this.config.boostContent;\n        }\n      }\n\n      searchTerms.forEach((term) =&gt; {\n        if (lowerTitle.includes(term)) {\n          match.pageScore +=\n            lowerTitle === term\n              ? this.config.boostTitle / 5\n              : this.config.boostTitle / 10;\n        }\n        if (lowerContent.includes(term)) {\n          match.pageScore += this.config.boostContent / 15;\n        }\n      });\n    }\n\n    if (options.signal?.aborted) {\n      return [];\n    }\n\n    pageMatches.forEach((match) =&gt; {\n      const doc = match.doc;\n      if (\n        !doc.anchors ||\n        !Array.isArray(doc.anchors) ||\n        doc.anchors.length === 0\n      ) {\n        return;\n      }\n\n      const anchorSet = new Set();\n\n      // Check for anchor text matches\n      doc.anchors.forEach((anchor) =&gt; {\n        if (!anchor || !anchor.text) return;\n\n        const anchorText = anchor.text.toLowerCase();\n        let anchorMatches = false;\n\n        if (useFuzzySearch) {\n          const fuzzyScore = this.fuzzyMatch(rawQuery, anchorText);\n          if (fuzzyScore !== null &amp;&amp; fuzzyScore &gt;= 0.4) {\n            anchorMatches = true;\n          }\n        }\n\n        if (!anchorMatches) {\n          searchTerms.forEach((term) =&gt; {\n            if (anchorText.includes(term)) {\n              anchorMatches = true;\n            }\n          });\n        }\n\n        if (anchorMatches) {\n          anchorSet.add(anchor.id);\n        }\n      });\n\n      // Check for content matches and find their containing sections\n      if (doc.content &amp;&amp; typeof doc.content === \&quot;string\&quot;) {\n        const lowerContent = doc.content.toLowerCase();\n\n        searchTerms.forEach((term) =&gt; {\n          let searchPos = 0;\n          let matchIndex;\n\n          while ((matchIndex = lowerContent.indexOf(term, searchPos)) !== -1) {\n            const containingAnchor = this.findContainingSection(\n              doc,\n              matchIndex,\n            );\n            if (containingAnchor &amp;&amp; !anchorSet.has(containingAnchor.id)) {\n              anchorSet.add(containingAnchor.id);\n            }\n            searchPos = matchIndex + term.length;\n          }\n        });\n      }\n\n      // Convert set back to anchor objects\n      doc.anchors.forEach((anchor) =&gt; {\n        if (anchorSet.has(anchor.id)) {\n          match.matchingAnchors.push(anchor);\n        }\n      });\n    });\n\n    const results = Array.from(pageMatches.values())\n      .filter((m) =&gt; m.pageScore &gt; 5)\n      .sort((a, b) =&gt; b.pageScore - a.pageScore)\n      .slice(0, limit);\n\n    return results;\n  }\n\n  // Generate search preview with highlighting\n  generatePreview(content, query, maxLength = 200) {\n    if (!content || typeof content !== \&quot;string\&quot;) {\n      return \&quot;\&quot;;\n    }\n\n    const lowerContent = content.toLowerCase();\n    const queryWords = this.tokenize(query);\n\n    // Find the best match position\n    let bestIndex = -1;\n    let bestMatch = \&quot;\&quot;;\n\n    for (const word of queryWords) {\n      const index = lowerContent.indexOf(word);\n      if (index !== -1 &amp;&amp; word.length &gt; bestMatch.length) {\n        bestIndex = index;\n        bestMatch = word;\n      }\n    }\n\n    // If no match found, show beginning\n    if (bestIndex === -1) {\n      const preview = content.slice(0, maxLength).trim();\n      const escaped = this.escapeHtml(preview);\n      return escaped + (content.length &gt; maxLength ? \&quot;...\&quot; : \&quot;\&quot;);\n    }\n\n    // Find paragraph boundaries around the match\n    const paragraphs = content.split(\&quot;\\n\&quot;).filter((p) =&gt; p.trim());\n    let currentPos = 0;\n    let matchParagraphIndex = -1;\n\n    for (let i = 0; i &lt; paragraphs.length; i++) {\n      const paragraphEnd = currentPos + paragraphs[i].length;\n      if (bestIndex &gt;= currentPos &amp;&amp; bestIndex &lt; paragraphEnd) {\n        matchParagraphIndex = i;\n        break;\n      }\n      currentPos = paragraphEnd + 1;\n    }\n\n    if (matchParagraphIndex === -1) {\n      matchParagraphIndex = 0;\n    }\n\n    // If matching paragraph is very short (likely a title/heading),\n    // prefer showing the next paragraph if it also contains the search term\n    if (\n      matchParagraphIndex &lt; paragraphs.length - 1 &amp;&amp;\n      paragraphs[matchParagraphIndex].length &lt; 50\n    ) {\n      const nextParagraph = paragraphs[matchParagraphIndex + 1];\n      if (nextParagraph.toLowerCase().includes(bestMatch)) {\n        matchParagraphIndex++;\n      }\n    }\n\n    // Get the matching paragraph\n    let preview = paragraphs[matchParagraphIndex];\n\n    // If paragraph is too long, extract context around match\n    if (preview.length &gt; maxLength) {\n      const matchInParagraph = preview.toLowerCase().indexOf(bestMatch);\n      if (matchInParagraph !== -1) {\n        const contextBefore = 60;\n        const contextAfter = 100;\n        const start = Math.max(0, matchInParagraph - contextBefore);\n        const end = Math.min(\n          preview.length,\n          matchInParagraph + bestMatch.length + contextAfter,\n        );\n        preview = preview.slice(start, end).trim();\n        if (start &gt; 0) preview = \&quot;...\&quot; + preview;\n        if (end &lt; paragraphs[matchParagraphIndex].length) preview += \&quot;...\&quot;;\n      } else {\n        preview = preview.slice(0, maxLength) + \&quot;...\&quot;;\n      }\n    }\n\n    return this.escapeHtml(preview);\n  }\n\n  // Escape HTML to prevent XSS\n  escapeHtml(text) {\n    if (!text || typeof text !== \&quot;string\&quot;) return \&quot;\&quot;;\n\n    const escapeMap = {\n      \&quot;&amp;\&quot;: \&quot;&amp;amp;\&quot;,\n      \&quot;&lt;\&quot;: \&quot;&amp;lt;\&quot;,\n      \&quot;&gt;\&quot;: \&quot;&amp;gt;\&quot;,\n      \&#39;\&quot;\&#39;: \&quot;&amp;quot;\&quot;,\n      \&quot;\&#39;\&quot;: \&quot;&amp;#x27;\&quot;,\n      \&quot;/\&quot;: \&quot;&amp;#x2F;\&quot;,\n    };\n\n    return text.replace(/[&amp;&lt;&gt;\&quot;\&#39;\\/]/g, (char) =&gt; escapeMap[char]);\n  }\n\n  // Highlight search terms in text\n  highlightTerms(text, terms) {\n    if (!text || typeof text !== \&quot;string\&quot;) return \&quot;\&quot;;\n    if (!Array.isArray(terms) || terms.length === 0) {\n      return this.escapeHtml(text);\n    }\n\n    // Escape HTML first\n    let highlighted = this.escapeHtml(text);\n\n    // Sort terms by length (longer first) to avoid overlapping highlights\n    const sortedTerms = [...terms].sort((a, b) =&gt; b.length - a.length);\n\n    sortedTerms.forEach((term) =&gt; {\n      if (!term || typeof term !== \&quot;string\&quot;) return;\n      const regex = new RegExp(`(${this.escapeRegex(term)})`, \&quot;gi\&quot;);\n      highlighted = highlighted.replace(regex, \&quot;&lt;mark&gt;$1&lt;/mark&gt;\&quot;);\n    });\n\n    return highlighted;\n  }\n\n  /**\n   * Web Worker search for large datasets\n   * @param {string} query - Search query\n   * @param {number} limit - Maximum results\n   * @returns {Promise&lt;Array&gt;} Search results\n   */\n  searchWithWorker(query, limit) {\n    const worker = initializeSearchWorker();\n    if (!worker) {\n      return this.fallbackSearch(query, limit);\n    }\n\n    return new Promise((resolve, reject) =&gt; {\n      const messageId = `search_${Date.now()}_${Math.random()\n        .toString(36)\n        .substring(2, 11)}`;\n      const timeout = setTimeout(() =&gt; {\n        cleanup();\n        reject(new Error(\&quot;Web Worker search timeout\&quot;));\n      }, 5000);\n\n      const handleMessage = (e) =&gt; {\n        if (e.data.messageId !== messageId) return;\n\n        clearTimeout(timeout);\n        cleanup();\n\n        if (e.data.type === \&quot;results\&quot;) {\n          resolve(e.data.data);\n        } else if (e.data.type === \&quot;error\&quot;) {\n          reject(new Error(e.data.error || \&quot;Unknown worker error\&quot;));\n        }\n      };\n\n      const handleError = (error) =&gt; {\n        clearTimeout(timeout);\n        cleanup();\n        reject(error);\n      };\n\n      const cleanup = () =&gt; {\n        worker.removeEventListener(\&quot;message\&quot;, handleMessage);\n        worker.removeEventListener(\&quot;error\&quot;, handleError);\n      };\n\n      worker.addEventListener(\&quot;message\&quot;, handleMessage);\n      worker.addEventListener(\&quot;error\&quot;, handleError);\n\n      worker.postMessage({\n        messageId,\n        type: \&quot;search\&quot;,\n        data: { query, limit },\n        documents: this.documents,\n      });\n    });\n  }\n\n  // Normalize text for comparison\n  normalizeForComparison(text) {\n    if (!text || typeof text !== \&quot;string\&quot;) return \&quot;\&quot;;\n    return text\n      .toLowerCase()\n      .replace(/\\s+/g, \&quot; \&quot;)\n      .replace(/[.,!?;:\&#39;\&quot;\u{2026}\u{2014}\u{2013}-]+$/g, \&quot;\&quot;)\n      .trim();\n  }\n\n  // Find which section/heading a content match belongs to\n  findContainingSection(doc, matchIndex) {\n    if (!doc.content || !doc.anchors || doc.anchors.length === 0) {\n      return null;\n    }\n\n    const paragraphs = doc.content.split(\&quot;\\n\&quot;).filter((p) =&gt; p.trim());\n\n    // Find which paragraph contains the match\n    let currentPos = 0;\n    let matchParagraphIndex = -1;\n\n    for (let i = 0; i &lt; paragraphs.length; i++) {\n      const paragraphEnd = currentPos + paragraphs[i].length;\n      if (matchIndex &gt;= currentPos &amp;&amp; matchIndex &lt; paragraphEnd) {\n        matchParagraphIndex = i;\n        break;\n      }\n      currentPos = paragraphEnd + 1;\n    }\n\n    if (matchParagraphIndex === -1) {\n      return null;\n    }\n\n    // Find the last heading that appears before this paragraph\n    let containingAnchor = null;\n\n    for (let i = 0; i &lt;= matchParagraphIndex; i++) {\n      const para = paragraphs[i].trim();\n      const matchingAnchor = doc.anchors.find((a) =&gt; {\n        const normalizedAnchor = this.normalizeForComparison(a.text);\n        const normalizedPara = this.normalizeForComparison(para);\n        return normalizedAnchor === normalizedPara;\n      });\n\n      if (matchingAnchor) {\n        containingAnchor = matchingAnchor;\n      }\n    }\n\n    return containingAnchor;\n  }\n\n  // Generate preview for a specific section\n  generateSectionPreview(doc, anchor, query, maxLength = 200) {\n    if (!doc.content || !anchor) {\n      return \&quot;\&quot;;\n    }\n\n    const paragraphs = doc.content.split(\&quot;\\n\&quot;).filter((p) =&gt; p.trim());\n\n    // Find where this section starts and ends\n    let sectionStart = -1;\n    let sectionEnd = paragraphs.length;\n\n    for (let i = 0; i &lt; paragraphs.length; i++) {\n      const para = paragraphs[i].trim();\n      const normalizedPara = this.normalizeForComparison(para);\n      const normalizedAnchor = this.normalizeForComparison(anchor.text);\n\n      if (normalizedPara === normalizedAnchor) {\n        sectionStart = i;\n      } else if (sectionStart !== -1 &amp;&amp; doc.anchors) {\n        // Check if this is another heading\n        const isHeading = doc.anchors.some((a) =&gt; {\n          const norm = this.normalizeForComparison(a.text);\n          return norm === normalizedPara;\n        });\n\n        if (isHeading) {\n          sectionEnd = i;\n          break;\n        }\n      }\n    }\n\n    if (sectionStart === -1) {\n      return \&quot;\&quot;;\n    }\n\n    // Get content of this section (excluding the heading itself)\n    const sectionParagraphs = paragraphs.slice(sectionStart + 1, sectionEnd);\n    const sectionContent = sectionParagraphs.join(\&quot;\\n\&quot;);\n\n    // Use existing generatePreview on just this section\&#39;s content\n    return this.generatePreview(sectionContent, query, maxLength);\n  }\n\n  // Escape regex special characters\n  escapeRegex(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \&quot;\\\\$&amp;\&quot;);\n  }\n\n  // Resolve path relative to current page location\n  resolvePath(path) {\n    // If path already starts with \&#39;/\&#39;, it\&#39;s absolute from domain root\n    if (path.startsWith(\&quot;/\&quot;)) {\n      return path;\n    }\n\n    // If path starts with \&#39;#\&#39;, it\&#39;s a fragment on current page\n    if (path.startsWith(\&quot;#\&quot;)) {\n      return path;\n    }\n\n    // Prepend root path for relative navigation\n    return this.rootPath + path;\n  }\n\n  // Lazy loading for search results\n  lazyLoadDocuments(docIds, limit = 10) {\n    if (!this.fullDocuments) {\n      // Store full documents separately for memory efficiency\n      this.fullDocuments = this.documents;\n      // Create lightweight index documents\n      this.documents = this.documents.map((doc) =&gt; ({\n        id: doc.id,\n        title: doc.title,\n        path: doc.path,\n      }));\n    }\n\n    return docIds.slice(0, limit).map((id) =&gt; this.fullDocuments[id]);\n  }\n\n  // Fallback search method via simple string matching\n  fallbackSearch(query, limit = 10) {\n    if (!query || typeof query !== \&quot;string\&quot;) return [];\n\n    const lowerQuery = query.toLowerCase();\n    if (lowerQuery.length &lt; 2) return [];\n\n    const results = this.documents\n      .map((doc) =&gt; {\n        if (!doc || !doc.title || !doc.content) {\n          return null;\n        }\n\n        const titleMatch = doc.title.toLowerCase().indexOf(lowerQuery);\n        const contentMatch = doc.content.toLowerCase().indexOf(lowerQuery);\n        let pageScore = 0;\n\n        if (titleMatch !== -1) {\n          pageScore += this.config.boostTitle / 10;\n          if (doc.title.toLowerCase() === lowerQuery) {\n            pageScore += this.config.boostTitle / 5;\n          }\n        }\n        if (contentMatch !== -1) {\n          pageScore += this.config.boostContent / 15;\n        }\n\n        // Find matching anchors\n        const matchingAnchors = [];\n        if (\n          doc.anchors &amp;&amp;\n          Array.isArray(doc.anchors) &amp;&amp;\n          doc.anchors.length &gt; 0\n        ) {\n          doc.anchors.forEach((anchor) =&gt; {\n            if (!anchor || !anchor.text) return;\n            const anchorText = anchor.text.toLowerCase();\n            if (anchorText.includes(lowerQuery)) {\n              matchingAnchors.push(anchor);\n            }\n          });\n        }\n\n        return { doc, pageScore, matchingAnchors, titleMatch, contentMatch };\n      })\n      .filter((item) =&gt; item !== null &amp;&amp; item.pageScore &gt; 0)\n      .sort((a, b) =&gt; {\n        if (a.pageScore !== b.pageScore) return b.pageScore - a.pageScore;\n        if (a.titleMatch !== b.titleMatch) return a.titleMatch - b.titleMatch;\n        return a.contentMatch - b.contentMatch;\n      })\n      .slice(0, limit);\n\n    return results;\n  }\n}\n\n// Web Worker for background search processing\n// Create Web Worker if supported - initialized lazily to use rootPath\nlet searchWorker = null;\n\n// Keyboard navigation helper class\nclass SearchKeyboardNav {\n  constructor(container, selector) {\n    this.container = container;\n    this.selector = selector;\n    this.activeIndex = -1;\n    this.items = [];\n    this.navigationPending = false;\n  }\n\n  updateItems() {\n    this.items = Array.from(this.container.querySelectorAll(this.selector));\n    if (this.activeIndex &gt;= this.items.length) {\n      this.activeIndex = -1;\n    }\n  }\n\n  clear() {\n    this.setActive(-1);\n    this.items = [];\n  }\n\n  setActive(index) {\n    // Remove active class from previous item\n    if (this.activeIndex &gt;= 0 &amp;&amp; this.activeIndex &lt; this.items.length) {\n      this.items[this.activeIndex].classList.remove(\&quot;search-result-active\&quot;);\n    }\n\n    this.activeIndex = index;\n\n    // Add active class to new item\n    if (this.activeIndex &gt;= 0 &amp;&amp; this.activeIndex &lt; this.items.length) {\n      this.items[this.activeIndex].classList.add(\&quot;search-result-active\&quot;);\n      this.items[this.activeIndex].scrollIntoView({\n        block: \&quot;nearest\&quot;,\n        behavior: \&quot;smooth\&quot;,\n      });\n    }\n  }\n\n  moveDown() {\n    if (this.items.length === 0) return;\n    const newIndex = Math.min(this.activeIndex + 1, this.items.length - 1);\n    this.setActive(newIndex);\n  }\n\n  moveUp() {\n    if (this.items.length === 0) return;\n    const newIndex = Math.max(this.activeIndex - 1, -1);\n    this.setActive(newIndex);\n  }\n\n  moveToFirst() {\n    if (this.items.length === 0) return;\n    this.setActive(0);\n  }\n\n  moveToLast() {\n    if (this.items.length === 0) return;\n    this.setActive(this.items.length - 1);\n  }\n\n  select() {\n    // Guard against double-navigation\n    if (this.navigationPending) return false;\n\n    if (this.activeIndex &gt;= 0 &amp;&amp; this.activeIndex &lt; this.items.length) {\n      const link = this.items[this.activeIndex].querySelector(\&quot;a\&quot;);\n      if (link) {\n        this.navigationPending = true;\n\n        // Add search query to URL if it\&#39;s a result link\n        const currentQuery =\n          this.container.closest(\&quot;.search-container\&quot;)?.querySelector(\&quot;input\&quot;)\n            ?.value || document.getElementById(\&quot;search-page-input\&quot;)?.value;\n        if (currentQuery) {\n          const url = new URL(link.href, window.location.origin);\n          url.searchParams.set(\&quot;highlight\&quot;, currentQuery);\n\n          // Clear flag after navigation starts\n          setTimeout(() =&gt; {\n            this.navigationPending = false;\n          }, 100);\n\n          window.location.href = url.toString();\n        } else {\n          // Clear flag before click to allow navigation\n          setTimeout(() =&gt; {\n            this.navigationPending = false;\n          }, 100);\n          link.click();\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nfunction debounce(func, wait) {\n  let timeout = null;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =&gt; func.apply(this, args), wait);\n  };\n}\n\nfunction initializeSearchWorker() {\n  if (searchWorker !== null || typeof Worker === \&quot;undefined\&quot;) {\n    return searchWorker;\n  }\n\n  try {\n    const rootPath = window.searchNamespace?.rootPath || \&quot;\&quot;;\n    const workerPath = rootPath\n      ? `${rootPath}assets/search-worker.js`\n      : \&quot;/assets/search-worker.js\&quot;;\n    searchWorker = new Worker(workerPath);\n    console.log(\&quot;Web Worker initialized for background search\&quot;);\n    return searchWorker;\n  } catch (error) {\n    console.warn(\&quot;Web Worker creation failed, using main thread:\&quot;, error);\n    searchWorker = false; // mark as failed so we don\&#39;t retry\n    return null;\n  }\n}\n\n// Global search engine instance\nwindow.searchNamespace.engine = new SearchEngine();\n\n// Mobile search timeout for debouncing\nlet mobileSearchTimeout = null;\n\n// AbortController for cancelling pending search requests\nlet searchPageController = null;\n\ndocument.addEventListener(\&quot;DOMContentLoaded\&quot;, function () {\n  // Initialize search engine immediately\n  window.searchNamespace.engine\n    .loadData()\n    .then(() =&gt; {\n      console.log(\&quot;Search data loaded successfully\&quot;);\n    })\n    .catch((error) =&gt; {\n      console.error(\&quot;Failed to initialize search:\&quot;, error);\n    });\n\n  // Search page specific functionality\n  const searchPageInput = document.getElementById(\&quot;search-page-input\&quot;);\n  if (searchPageInput) {\n    // Initialize keyboard navigation for search page\n    const searchPageResults = document.getElementById(\&quot;search-page-results\&quot;);\n    const searchPageKeyboardNav = new SearchKeyboardNav(\n      searchPageResults,\n      \&quot;.search-result-item\&quot;,\n    );\n\n    // Keyboard navigation for search page\n    searchPageInput.addEventListener(\&quot;keydown\&quot;, function (event) {\n      const hasResults =\n        searchPageResults &amp;&amp;\n        searchPageResults.querySelector(\&quot;.search-result-item\&quot;);\n\n      if (!hasResults) return;\n\n      if (event.key === \&quot;ArrowDown\&quot;) {\n        event.preventDefault();\n        searchPageKeyboardNav.moveDown();\n      } else if (event.key === \&quot;ArrowUp\&quot;) {\n        event.preventDefault();\n        searchPageKeyboardNav.moveUp();\n      } else if (event.key === \&quot;Home\&quot;) {\n        event.preventDefault();\n        searchPageKeyboardNav.moveToFirst();\n      } else if (event.key === \&quot;End\&quot;) {\n        event.preventDefault();\n        searchPageKeyboardNav.moveToLast();\n      } else if (\n        event.key === \&quot;Enter\&quot; &amp;&amp;\n        searchPageKeyboardNav.activeIndex &gt;= 0\n      ) {\n        event.preventDefault();\n        searchPageKeyboardNav.select();\n      } else if (event.key === \&quot;Escape\&quot;) {\n        event.preventDefault();\n        searchPageKeyboardNav.clear();\n        searchPageInput.blur();\n      }\n    });\n\n    // Set up event listener with debouncing\n    searchPageInput.addEventListener(\n      \&quot;input\&quot;,\n      debounce(function () {\n        const query = this.value.trim();\n        if (query.length &gt;= 2) {\n          performSearch(query, searchPageKeyboardNav);\n        } else {\n          const resultsContainer = document.getElementById(\n            \&quot;search-page-results\&quot;,\n          );\n          if (resultsContainer) {\n            resultsContainer.innerHTML =\n              \&quot;&lt;p&gt;Please enter at least 2 characters to search&lt;/p&gt;\&quot;;\n          }\n          searchPageKeyboardNav.clear();\n        }\n      }, 200),\n    );\n\n    // Perform search if URL has query\n    const params = new URLSearchParams(window.location.search);\n    const query = params.get(\&quot;q\&quot;);\n    if (query) {\n      searchPageInput.value = query;\n      performSearch(query, searchPageKeyboardNav);\n    }\n  }\n\n  // Desktop Sidebar Toggle\n  const searchInput = document.getElementById(\&quot;search-input\&quot;);\n  if (searchInput) {\n    const searchResults = document.getElementById(\&quot;search-results\&quot;);\n    const searchContainer = searchInput.closest(\&quot;.search-container\&quot;);\n    // Initialize keyboard navigation for desktop search\n    const desktopKeyboardNav = new SearchKeyboardNav(\n      searchResults,\n      \&quot;.search-result-item\&quot;,\n    );\n\n    searchInput.addEventListener(\n      \&quot;input\&quot;,\n      debounce(async function () {\n        const searchTerm = this.value.trim();\n        const currentSearchTerm = searchTerm;\n\n        if (searchTerm.length &lt; 2) {\n          searchResults.innerHTML = \&quot;\&quot;;\n          searchResults.style.display = \&quot;none\&quot;;\n          if (searchContainer) searchContainer.classList.remove(\&quot;has-results\&quot;);\n          desktopKeyboardNav.clear();\n          return;\n        }\n\n        searchResults.innerHTML =\n          \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;Loading...&lt;/div&gt;\&#39;;\n        searchResults.style.display = \&quot;block\&quot;;\n        if (searchContainer) searchContainer.classList.add(\&quot;has-results\&quot;);\n\n        try {\n          const results = await window.searchNamespace.engine.search(\n            searchTerm,\n            8,\n          );\n\n          if (currentSearchTerm !== searchTerm) return;\n\n          if (results.length &gt; 0) {\n            searchResults.innerHTML = results\n              .map((result) =&gt; {\n                const { doc, matchingAnchors } = result;\n                const queryTerms =\n                  window.searchNamespace.engine.tokenize(searchTerm);\n                const highlightedTitle =\n                  window.searchNamespace.engine.highlightTerms(\n                    doc.title,\n                    queryTerms,\n                  );\n                const resolvedPath = window.searchNamespace.engine.resolvePath(\n                  doc.path,\n                );\n\n                let html = `\n                &lt;div class=\&quot;search-result-item search-result-page\&quot;&gt;\n                  &lt;a href=\&quot;${resolvedPath}\&quot;&gt;${highlightedTitle}&lt;/a&gt;\n                &lt;/div&gt;\n              `;\n\n                if (matchingAnchors &amp;&amp; matchingAnchors.length &gt; 0) {\n                  matchingAnchors.forEach((anchor) =&gt; {\n                    // Skip anchors that duplicate the page title\n                    const normalizedAnchor =\n                      window.searchNamespace.engine.normalizeForComparison(\n                        anchor.text,\n                      );\n                    const normalizedTitle =\n                      window.searchNamespace.engine.normalizeForComparison(\n                        doc.title,\n                      );\n                    if (normalizedAnchor === normalizedTitle) {\n                      return;\n                    }\n\n                    const highlightedAnchor =\n                      window.searchNamespace.engine.highlightTerms(\n                        anchor.text,\n                        queryTerms,\n                      );\n                    const anchorPath = `${resolvedPath}#${anchor.id}`;\n                    html += `\n                    &lt;div class=\&quot;search-result-item search-result-anchor\&quot;&gt;\n                      &lt;a href=\&quot;${anchorPath}\&quot;&gt;${highlightedAnchor}&lt;/a&gt;\n                    &lt;/div&gt;\n                  `;\n                  });\n                }\n\n                return html;\n              })\n              .join(\&quot;\&quot;);\n            searchResults.style.display = \&quot;block\&quot;;\n            if (searchContainer) searchContainer.classList.add(\&quot;has-results\&quot;);\n            desktopKeyboardNav.updateItems();\n          } else {\n            searchResults.innerHTML =\n              \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;No results found&lt;/div&gt;\&#39;;\n            searchResults.style.display = \&quot;block\&quot;;\n            if (searchContainer) searchContainer.classList.add(\&quot;has-results\&quot;);\n          }\n        } catch (error) {\n          console.error(\&quot;Search error:\&quot;, error);\n          searchResults.innerHTML =\n            \&#39;&lt;div class=\&quot;search-result-item search-error\&quot; role=\&quot;alert\&quot;&gt;Search unavailable. &lt;a href=\&quot;#\&quot; onclick=\&quot;event.preventDefault(); window.searchNamespace.engine.loadData();\&quot;&gt;Retry&lt;/a&gt;&lt;/div&gt;\&#39;;\n          searchResults.style.display = \&quot;block\&quot;;\n          if (searchContainer) searchContainer.classList.add(\&quot;has-results\&quot;);\n        }\n      }, 150),\n    );\n\n    // Hide results when clicking outside\n    document.addEventListener(\&quot;click\&quot;, function (event) {\n      if (\n        !searchInput.contains(event.target) &amp;&amp;\n        !searchResults.contains(event.target)\n      ) {\n        searchResults.style.display = \&quot;none\&quot;;\n        if (searchContainer) searchContainer.classList.remove(\&quot;has-results\&quot;);\n        desktopKeyboardNav.clear();\n      }\n    });\n\n    // Keyboard navigation for desktop search\n    searchInput.addEventListener(\&quot;keydown\&quot;, function (event) {\n      if (searchResults.style.display !== \&quot;block\&quot;) return;\n\n      if (event.key === \&quot;ArrowDown\&quot;) {\n        event.preventDefault();\n        desktopKeyboardNav.moveDown();\n      } else if (event.key === \&quot;ArrowUp\&quot;) {\n        event.preventDefault();\n        desktopKeyboardNav.moveUp();\n      } else if (event.key === \&quot;Home\&quot;) {\n        event.preventDefault();\n        desktopKeyboardNav.moveToFirst();\n      } else if (event.key === \&quot;End\&quot;) {\n        event.preventDefault();\n        desktopKeyboardNav.moveToLast();\n      } else if (event.key === \&quot;Enter\&quot; &amp;&amp; desktopKeyboardNav.activeIndex &gt;= 0) {\n        event.preventDefault();\n        desktopKeyboardNav.select();\n      } else if (event.key === \&quot;Escape\&quot;) {\n        event.preventDefault();\n        searchResults.style.display = \&quot;none\&quot;;\n        if (searchContainer) searchContainer.classList.remove(\&quot;has-results\&quot;);\n        desktopKeyboardNav.clear();\n        searchInput.blur();\n      }\n    });\n\n    // Focus search when pressing slash key\n    document.addEventListener(\&quot;keydown\&quot;, function (event) {\n      if (event.key === \&quot;/\&quot; &amp;&amp; document.activeElement !== searchInput) {\n        event.preventDefault();\n        searchInput.focus();\n      }\n    });\n\n    setupDocumentEventHandlers(searchInput, searchResults, searchContainer);\n  }\n\n  function setupDocumentEventHandlers(\n    searchInput,\n    searchResults,\n    searchContainer,\n  ) {\n    document.addEventListener(\&quot;click\&quot;, function (event) {\n      const isMobileSearchActive =\n        mobileSearchPopup &amp;&amp; mobileSearchPopup.classList.contains(\&quot;active\&quot;);\n      const isDesktopResultsVisible = searchResults.style.display === \&quot;block\&quot;;\n\n      if (\n        isMobileSearchActive &amp;&amp;\n        !mobileSearchPopup.contains(event.target) &amp;&amp;\n        !searchInput.contains(event.target)\n      ) {\n        closeMobileSearch();\n      }\n\n      if (\n        isDesktopResultsVisible &amp;&amp;\n        !searchInput.contains(event.target) &amp;&amp;\n        !searchResults.contains(event.target)\n      ) {\n        searchResults.style.display = \&quot;none\&quot;;\n        if (searchContainer) searchContainer.classList.remove(\&quot;has-results\&quot;);\n      }\n    });\n\n    document.addEventListener(\&quot;keydown\&quot;, function (event) {\n      if (event.key === \&quot;/\&quot; &amp;&amp; document.activeElement !== searchInput) {\n        event.preventDefault();\n        searchInput.focus();\n      }\n\n      if (\n        event.key === \&quot;Escape\&quot; &amp;&amp;\n        (document.activeElement === searchInput ||\n          searchResults.style.display === \&quot;block\&quot;)\n      ) {\n        searchResults.style.display = \&quot;none\&quot;;\n        if (searchContainer) searchContainer.classList.remove(\&quot;has-results\&quot;);\n        searchInput.blur();\n      }\n\n      if (\n        event.key === \&quot;Escape\&quot; &amp;&amp;\n        mobileSearchPopup &amp;&amp;\n        mobileSearchPopup.classList.contains(\&quot;active\&quot;)\n      ) {\n        closeMobileSearch();\n      }\n    });\n  }\n\n  // Mobile search functionality\n  // This detects mobile viewport and adds click behavior\n  function isMobile() {\n    return window.innerWidth &lt;= 800;\n  }\n\n  if (searchInput) {\n    // Add mobile search behavior\n    searchInput.addEventListener(\&quot;click\&quot;, function (e) {\n      if (isMobile()) {\n        e.preventDefault();\n        e.stopPropagation();\n        openMobileSearch();\n      }\n      // On desktop, we let the normal click behavior work (focus the input)\n    });\n\n    // Prevent typing on mobile (input should only open popup)\n    searchInput.addEventListener(\&quot;keydown\&quot;, function (e) {\n      if (isMobile()) {\n        e.preventDefault();\n        openMobileSearch();\n      }\n    });\n  }\n\n  // Mobile search popup functionality\n  const mobileSearchPopup = document.getElementById(\&quot;mobile-search-popup\&quot;);\n  const mobileSearchInput = document.getElementById(\&quot;mobile-search-input\&quot;);\n  const mobileSearchResults = document.getElementById(\&quot;mobile-search-results\&quot;);\n  const closeMobileSearchBtn = document.getElementById(\&quot;close-mobile-search\&quot;);\n\n  // Store cleanup function to prevent memory leaks\n  let mobileFocusTrapCleanup = null;\n\n  function setupMobileFocusTrap() {\n    if (!mobileSearchPopup || !mobileSearchPopup.classList.contains(\&quot;active\&quot;))\n      return;\n\n    const focusableElements = [\n      mobileSearchInput,\n      closeMobileSearchBtn,\n      ...Array.from(mobileSearchResults.querySelectorAll(\&quot;a[href]\&quot;)),\n    ].filter((el) =&gt; el !== null);\n\n    if (focusableElements.length === 0) return;\n\n    const firstFocusable = focusableElements[0];\n    const lastFocusable = focusableElements[focusableElements.length - 1];\n\n    const handleKeyDown = (e) =&gt; {\n      if (e.key === \&quot;Tab\&quot;) {\n        if (e.shiftKey &amp;&amp; document.activeElement === firstFocusable) {\n          e.preventDefault();\n          lastFocusable.focus();\n        } else if (!e.shiftKey &amp;&amp; document.activeElement === lastFocusable) {\n          e.preventDefault();\n          firstFocusable.focus();\n        }\n      }\n\n      if (e.key === \&quot;Escape\&quot;) {\n        closeMobileSearch();\n      }\n\n      // Arrow key navigation in results\n      if ([\&quot;ArrowDown\&quot;, \&quot;ArrowUp\&quot;].includes(e.key)) {\n        const links = Array.from(\n          mobileSearchResults.querySelectorAll(\&quot;a[href]\&quot;),\n        );\n        if (links.length === 0) return;\n\n        const currentIndex = links.indexOf(document.activeElement);\n\n        if (e.key === \&quot;ArrowDown\&quot;) {\n          e.preventDefault();\n          if (currentIndex === -1) {\n            links[0].focus();\n          } else {\n            const nextIndex = Math.min(currentIndex + 1, links.length - 1);\n            links[nextIndex].focus();\n          }\n        } else if (e.key === \&quot;ArrowUp\&quot;) {\n          e.preventDefault();\n          if (currentIndex &gt; 0) {\n            links[currentIndex - 1].focus();\n          } else if (currentIndex === 0) {\n            mobileSearchInput.focus();\n          }\n        }\n      }\n    };\n\n    mobileSearchPopup.addEventListener(\&quot;keydown\&quot;, handleKeyDown);\n\n    // Return cleanup function\n    return () =&gt; {\n      mobileSearchPopup.removeEventListener(\&quot;keydown\&quot;, handleKeyDown);\n    };\n  }\n\n  function openMobileSearch() {\n    if (mobileSearchPopup) {\n      mobileSearchPopup.classList.add(\&quot;active\&quot;);\n      // Focus the input after a small delay to ensure the popup is visible\n      setTimeout(() =&gt; {\n        if (mobileSearchInput) {\n          mobileSearchInput.focus();\n        }\n        // Clean up previous session\&#39;s listeners before setting up new ones\n        if (mobileFocusTrapCleanup) {\n          mobileFocusTrapCleanup();\n          mobileFocusTrapCleanup = null;\n        }\n        mobileFocusTrapCleanup = setupMobileFocusTrap();\n      }, 100);\n    }\n  }\n\n  function closeMobileSearch() {\n    if (mobileSearchPopup) {\n      // Clean up event listeners before closing\n      if (mobileFocusTrapCleanup) {\n        mobileFocusTrapCleanup();\n        mobileFocusTrapCleanup = null;\n      }\n      mobileSearchPopup.classList.remove(\&quot;active\&quot;);\n      if (mobileSearchInput) {\n        mobileSearchInput.value = \&quot;\&quot;;\n      }\n      if (mobileSearchResults) {\n        mobileSearchResults.innerHTML = \&quot;\&quot;;\n        mobileSearchResults.style.display = \&quot;none\&quot;;\n      }\n    }\n  }\n\n  if (closeMobileSearchBtn) {\n    closeMobileSearchBtn.addEventListener(\&quot;click\&quot;, closeMobileSearch);\n  }\n\n  // Mobile search input\n  if (mobileSearchInput &amp;&amp; mobileSearchResults) {\n    function handleMobileSearchInput() {\n      clearTimeout(mobileSearchTimeout);\n      const searchTerm = mobileSearchInput.value.trim();\n      if (searchTerm.length &lt; 2) {\n        mobileSearchResults.innerHTML = \&quot;\&quot;;\n        mobileSearchResults.style.display = \&quot;none\&quot;;\n        return;\n      }\n\n      mobileSearchTimeout = setTimeout(async () =&gt; {\n        // Verify the input still matches before proceeding\n        if (mobileSearchInput.value.trim() !== searchTerm) return;\n\n        // Show loading state\n        mobileSearchResults.innerHTML =\n          \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;Loading...&lt;/div&gt;\&#39;;\n        mobileSearchResults.style.display = \&quot;block\&quot;;\n\n        try {\n          const results = await window.searchNamespace.engine.search(\n            searchTerm,\n            8,\n          );\n          // Verify again after async operation\n          if (mobileSearchInput.value.trim() !== searchTerm) return;\n\n          if (results.length &gt; 0) {\n            mobileSearchResults.innerHTML = results\n              .map((result) =&gt; {\n                const { doc, matchingAnchors } = result;\n                const queryTerms =\n                  window.searchNamespace.engine.tokenize(searchTerm);\n                const highlightedTitle =\n                  window.searchNamespace.engine.highlightTerms(\n                    doc.title,\n                    queryTerms,\n                  );\n                const resolvedPath = window.searchNamespace.engine.resolvePath(\n                  doc.path,\n                );\n\n                // Build page result\n                let html = `\n                  &lt;div class=\&quot;search-result-item search-result-page\&quot;&gt;\n                    &lt;a href=\&quot;${resolvedPath}\&quot;&gt;${highlightedTitle}&lt;/a&gt;\n                  &lt;/div&gt;\n                `;\n\n                // Add anchor results if any\n                if (matchingAnchors &amp;&amp; matchingAnchors.length &gt; 0) {\n                  matchingAnchors.forEach((anchor) =&gt; {\n                    // Skip anchors that duplicate the page title\n                    const normalizedAnchor =\n                      window.searchNamespace.engine.normalizeForComparison(\n                        anchor.text,\n                      );\n                    const normalizedTitle =\n                      window.searchNamespace.engine.normalizeForComparison(\n                        doc.title,\n                      );\n                    if (normalizedAnchor === normalizedTitle) {\n                      return;\n                    }\n\n                    const highlightedAnchor =\n                      window.searchNamespace.engine.highlightTerms(\n                        anchor.text,\n                        queryTerms,\n                      );\n                    const sectionPreview =\n                      window.searchNamespace.engine.generateSectionPreview(\n                        doc,\n                        anchor,\n                        searchTerm,\n                        100,\n                      );\n                    const anchorPath = `${resolvedPath}#${anchor.id}`;\n                    html += `\n                      &lt;div class=\&quot;search-result-item search-result-anchor\&quot;&gt;\n                        &lt;a href=\&quot;${anchorPath}\&quot;&gt;\n                          &lt;div class=\&quot;search-result-anchor-text\&quot;&gt;${highlightedAnchor}&lt;/div&gt;\n                          &lt;div class=\&quot;search-result-preview\&quot;&gt;${sectionPreview}&lt;/div&gt;\n                        &lt;/a&gt;\n                      &lt;/div&gt;\n                    `;\n                  });\n                }\n\n                return html;\n              })\n              .join(\&quot;\&quot;);\n            mobileSearchResults.style.display = \&quot;block\&quot;;\n            // Clean up previous listeners before setting up new ones\n            if (mobileFocusTrapCleanup) {\n              mobileFocusTrapCleanup();\n              mobileFocusTrapCleanup = null;\n            }\n            mobileFocusTrapCleanup = setupMobileFocusTrap();\n          } else {\n            mobileSearchResults.innerHTML =\n              \&#39;&lt;div class=\&quot;search-result-item\&quot;&gt;No results found&lt;/div&gt;\&#39;;\n            mobileSearchResults.style.display = \&quot;block\&quot;;\n          }\n        } catch (error) {\n          console.error(\&quot;Mobile search error:\&quot;, error);\n          // Verify once more\n          if (mobileSearchInput.value.trim() !== searchTerm) return;\n          mobileSearchResults.innerHTML =\n            \&#39;&lt;div class=\&quot;search-result-item search-error\&quot; role=\&quot;alert\&quot;&gt;Search unavailable. &lt;a href=\&quot;#\&quot; onclick=\&quot;event.preventDefault(); window.searchNamespace.engine.loadData();\&quot;&gt;Retry&lt;/a&gt;&lt;/div&gt;\&#39;;\n          mobileSearchResults.style.display = \&quot;block\&quot;;\n        }\n      }, 300);\n    }\n\n    mobileSearchInput.addEventListener(\&quot;input\&quot;, handleMobileSearchInput);\n  }\n\n  // Handle window resize to update mobile behavior\n  window.addEventListener(\&quot;resize\&quot;, function () {\n    // Close mobile search if window is resized to desktop size\n    if (\n      !isMobile() &amp;&amp;\n      mobileSearchPopup &amp;&amp;\n      mobileSearchPopup.classList.contains(\&quot;active\&quot;)\n    ) {\n      closeMobileSearch();\n    }\n  });\n});\n\nasync function performSearch(query, keyboardNav = null) {\n  query = query.trim();\n  const resultsContainer = document.getElementById(\&quot;search-page-results\&quot;);\n\n  if (query.length &lt; 2) {\n    resultsContainer.innerHTML =\n      \&quot;&lt;p&gt;Please enter at least 2 characters to search&lt;/p&gt;\&quot;;\n    if (keyboardNav) keyboardNav.clear();\n    return;\n  }\n\n  // Cancel any pending search\n  if (searchPageController) {\n    searchPageController.abort();\n  }\n  searchPageController = new AbortController();\n\n  // Show loading state\n  resultsContainer.innerHTML = \&quot;&lt;p&gt;Searching...&lt;/p&gt;\&quot;;\n  if (keyboardNav) keyboardNav.clear();\n\n  try {\n    const results = await window.searchNamespace.engine.search(query, 50, {\n      signal: searchPageController.signal,\n    });\n\n    // Check if aborted before rendering\n    if (searchPageController.signal.aborted) {\n      return;\n    }\n\n    // Display results\n    if (results.length &gt; 0) {\n      let html = \&#39;&lt;ul class=\&quot;search-results-list\&quot;&gt;\&#39;;\n      const queryTerms = window.searchNamespace.engine.tokenize(query);\n\n      for (const result of results) {\n        const { doc, matchingAnchors } = result;\n        const highlightedTitle = window.searchNamespace.engine.highlightTerms(\n          doc.title,\n          queryTerms,\n        );\n        const preview = window.searchNamespace.engine.generatePreview(\n          doc.content,\n          query,\n        );\n        const resolvedPath = window.searchNamespace.engine.resolvePath(\n          doc.path,\n        );\n\n        // Page result\n        html += `&lt;li class=\&quot;search-result-item search-result-page\&quot;&gt;\n          &lt;a href=\&quot;${resolvedPath}\&quot;&gt;\n            &lt;div class=\&quot;search-result-title\&quot;&gt;${highlightedTitle}&lt;/div&gt;\n            &lt;div class=\&quot;search-result-preview\&quot;&gt;${preview}&lt;/div&gt;\n          &lt;/a&gt;\n        &lt;/li&gt;`;\n\n        // Anchor results\n        if (matchingAnchors &amp;&amp; matchingAnchors.length &gt; 0) {\n          matchingAnchors.forEach((anchor) =&gt; {\n            // Skip anchors that have the same text as the page title to avoid duplication\n            const normalizedAnchor =\n              window.searchNamespace.engine.normalizeForComparison(anchor.text);\n            const normalizedTitle =\n              window.searchNamespace.engine.normalizeForComparison(doc.title);\n            if (normalizedAnchor === normalizedTitle) {\n              return;\n            }\n\n            const highlightedAnchor =\n              window.searchNamespace.engine.highlightTerms(\n                anchor.text,\n                queryTerms,\n              );\n            const sectionPreview =\n              window.searchNamespace.engine.generateSectionPreview(\n                doc,\n                anchor,\n                query,\n              );\n            const anchorPath = `${resolvedPath}#${anchor.id}`;\n            html += `&lt;li class=\&quot;search-result-item search-result-anchor\&quot;&gt;\n              &lt;a href=\&quot;${anchorPath}\&quot;&gt;\n                &lt;div class=\&quot;search-result-anchor-text\&quot;&gt;${highlightedAnchor}&lt;/div&gt;\n                &lt;div class=\&quot;search-result-preview\&quot;&gt;${sectionPreview}&lt;/div&gt;\n              &lt;/a&gt;\n            &lt;/li&gt;`;\n          });\n        }\n      }\n      html += \&quot;&lt;/ul&gt;\&quot;;\n      resultsContainer.innerHTML = html;\n      if (keyboardNav) keyboardNav.updateItems();\n    } else {\n      resultsContainer.innerHTML = \&quot;&lt;p&gt;No results found&lt;/p&gt;\&quot;;\n      if (keyboardNav) keyboardNav.clear();\n    }\n\n    // Update URL with query\n    const url = new URL(window.location.href);\n    url.searchParams.set(\&quot;q\&quot;, query);\n    window.history.replaceState({}, \&quot;\&quot;, url.toString());\n  } catch (error) {\n    if (error.name === \&quot;AbortError\&quot;) {\n      return;\n    }\n    console.error(\&quot;Search error:\&quot;, error);\n    resultsContainer.innerHTML = `\n      &lt;div class=\&quot;search-error\&quot; role=\&quot;alert\&quot;&gt;\n        &lt;p&gt;Search is temporarily unavailable. Please try again.&lt;/p&gt;\n        &lt;button type=\&quot;button\&quot; onclick=\&quot;window.searchNamespace.engine.loadData().then(() =&gt; { this.closest(\&#39;.search-error\&#39;).innerHTML = \&#39;&lt;p&gt;Search reloaded. Please try your search again.&lt;/p&gt;\&#39;; })\&quot;&gt;\n          Retry\n        &lt;/button&gt;\n      &lt;/div&gt;\n    `;\n    if (keyboardNav) keyboardNav.clear();\n  }\n}\n&quot;;</code></pre></section></div></main></body></html>